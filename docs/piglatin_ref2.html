<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="Apache Forrest" name="Generator">
<meta name="Forrest-version" content="0.8">
<meta name="Forrest-skin-name" content="pelt">
<title>Pig Latin Reference Manual 2</title>
<link type="text/css" href="skin/basic.css" rel="stylesheet">
<link media="screen" type="text/css" href="skin/screen.css" rel="stylesheet">
<link media="print" type="text/css" href="skin/print.css" rel="stylesheet">
<link type="text/css" href="skin/profile.css" rel="stylesheet">
<script src="skin/getBlank.js" language="javascript" type="text/javascript"></script><script src="skin/getMenu.js" language="javascript" type="text/javascript"></script><script src="skin/fontsize.js" language="javascript" type="text/javascript"></script>
<link rel="shortcut icon" href="">
</head>
<body onload="init()">
<script type="text/javascript">ndeSetTextSize();</script>
<div id="top">
<!--+
    |breadtrail
    +-->
<div class="breadtrail">
<a href="http://www.apache.org/">Apache</a> &gt; <a href="http://hadoop.apache.org/">Hadoop</a> &gt; <a href="http://hadoop.apache.org/pig/">Pig</a><script src="skin/breadcrumbs.js" language="JavaScript" type="text/javascript"></script>
</div>
<!--+
    |header
    +-->
<div class="header">
<!--+
    |start group logo
    +-->
<div class="grouplogo">
<a href="http://hadoop.apache.org/"><img class="logoImage" alt="Hadoop" src="images/hadoop-logo.jpg" title="Apache Hadoop"></a>
</div>
<!--+
    |end group logo
    +-->
<!--+
    |start Project Logo
    +-->
<div class="projectlogo">
<a href="http://hadoop.apache.org/pig/"><img class="logoImage" alt="Pig" src="images/pig-logo.gif" title="A platform for analyzing large datasets."></a>
</div>
<!--+
    |end Project Logo
    +-->
<!--+
    |start Search
    +-->
<div class="searchbox">
<form action="http://www.google.com/search" method="get" class="roundtopsmall">
<input value="" name="sitesearch" type="hidden"><input onFocus="getBlank (this, 'Search the site with google');" size="25" name="q" id="query" type="text" value="Search the site with google">&nbsp; 
                    <input name="Search" value="Search" type="submit">
</form>
</div>
<!--+
    |end search
    +-->
<!--+
    |start Tabs
    +-->
<ul id="tabs">
<li>
<a class="unselected" href="http://hadoop.apache.org/pig/">Project</a>
</li>
<li>
<a class="unselected" href="http://wiki.apache.org/pig/">Wiki</a>
</li>
<li class="current">
<a class="selected" href="index.html">Pig 0.7.0 Documentation</a>
</li>
</ul>
<!--+
    |end Tabs
    +-->
</div>
</div>
<div id="main">
<div id="publishedStrip">
<!--+
    |start Subtabs
    +-->
<div id="level2tabs"></div>
<!--+
    |end Endtabs
    +-->
<script type="text/javascript"><!--
document.write("Last Published: " + document.lastModified);
//  --></script>
</div>
<!--+
    |breadtrail
    +-->
<div class="breadtrail">

             &nbsp;
           </div>
<!--+
    |start Menu, mainarea
    +-->
<!--+
    |start Menu
    +-->
<div id="menu">
<div onclick="SwitchMenu('menu_selected_1.1', 'skin/')" id="menu_selected_1.1Title" class="menutitle" style="background-image: url('skin/images/chapter_open.gif');">Pig</div>
<div id="menu_selected_1.1" class="selectedmenuitemgroup" style="display: block;">
<div class="menuitem">
<a href="index.html">Overview</a>
</div>
<div class="menuitem">
<a href="setup.html">Setup</a>
</div>
<div class="menuitem">
<a href="tutorial.html">Tutorial</a>
</div>
<div class="menuitem">
<a href="piglatin_ref1.html">Pig Latin 1</a>
</div>
<div class="menupage">
<div class="menupagetitle">Pig Latin 2</div>
</div>
<div class="menuitem">
<a href="cookbook.html">Cookbook</a>
</div>
<div class="menuitem">
<a href="udf.html">UDFs</a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.2', 'skin/')" id="menu_1.2Title" class="menutitle">Zebra</div>
<div id="menu_1.2" class="menuitemgroup">
<div class="menuitem">
<a href="zebra_overview.html">Zebra Overview </a>
</div>
<div class="menuitem">
<a href="zebra_users.html">Zebra Users </a>
</div>
<div class="menuitem">
<a href="zebra_reference.html">Zebra Reference </a>
</div>
<div class="menuitem">
<a href="zebra_mapreduce.html">Zebra MapReduce </a>
</div>
<div class="menuitem">
<a href="zebra_pig.html">Zebra Pig </a>
</div>
<div class="menuitem">
<a href="zebra_stream.html">Zebra Streaming </a>
</div>
</div>
<div onclick="SwitchMenu('menu_1.3', 'skin/')" id="menu_1.3Title" class="menutitle">Miscellaneous</div>
<div id="menu_1.3" class="menuitemgroup">
<div class="menuitem">
<a href="api/">API Docs</a>
</div>
<div class="menuitem">
<a href="http://wiki.apache.org/pig/">Wiki</a>
</div>
<div class="menuitem">
<a href="http://wiki.apache.org/pig/FAQ">FAQ</a>
</div>
<div class="menuitem">
<a href="http://hadoop.apache.org/pig/releases.html">Release Notes</a>
</div>
</div>
<div id="credit"></div>
<div id="roundbottom">
<img style="display: none" class="corner" height="15" width="15" alt="" src="skin/images/rc-b-l-15-1body-2menu-3menu.png"></div>
<!--+
  |alternative credits
  +-->
<div id="credit2"></div>
</div>
<!--+
    |end Menu
    +-->
<!--+
    |start content
    +-->
<div id="content">
<div title="Portable Document Format" class="pdflink">
<a class="dida" href="piglatin_ref2.pdf"><img alt="PDF -icon" src="skin/images/pdfdoc.gif" class="skin"><br>
        PDF</a>
</div>
<h1>Pig Latin Reference Manual 2</h1>
<div id="minitoc-area">
<ul class="minitoc">
<li>
<a href="#Overview">Overview</a>
<ul class="minitoc">
<li>
<a href="#Conventions">Conventions</a>
</li>
<li>
<a href="#Keywords">Keywords</a>
</li>
</ul>
</li>
<li>
<a href="#Data+Types+and+More">Data Types and More</a>
<ul class="minitoc">
<li>
<a href="#Relations%2C+Bags%2C+Tuples%2C+Fields">Relations, Bags, Tuples, Fields</a>
</li>
<li>
<a href="#Data+Types">Data Types</a>
</li>
<li>
<a href="#Nulls">Nulls</a>
</li>
<li>
<a href="#Constants">Constants</a>
</li>
<li>
<a href="#Expressions">Expressions</a>
</li>
<li>
<a href="#Schemas">Schemas</a>
</li>
<li>
<a href="#Parameter+Substitution">Parameter Substitution</a>
</li>
</ul>
</li>
<li>
<a href="#Arithmetic+Operators+and+More">Arithmetic Operators and More</a>
<ul class="minitoc">
<li>
<a href="#Arithmetic+Operators">Arithmetic Operators</a>
</li>
<li>
<a href="#Comparison+Operators">Comparison Operators</a>
</li>
<li>
<a href="#Null+Operators">Null Operators</a>
</li>
<li>
<a href="#boolops">Boolean Operators</a>
</li>
<li>
<a href="#deref">Dereference Operators</a>
</li>
<li>
<a href="#Sign+Operators">Sign Operators</a>
</li>
<li>
<a href="#Flatten+Operator">Flatten Operator</a>
</li>
<li>
<a href="#Cast+Operators">Cast Operators</a>
</li>
</ul>
</li>
<li>
<a href="#Relational+Operators">Relational Operators</a>
<ul class="minitoc">
<li>
<a href="#COGROUP">COGROUP</a>
</li>
<li>
<a href="#CROSS">CROSS</a>
</li>
<li>
<a href="#DISTINCT">DISTINCT </a>
</li>
<li>
<a href="#FILTER">FILTER </a>
</li>
<li>
<a href="#FOREACH">FOREACH</a>
</li>
<li>
<a href="#GROUP">GROUP</a>
</li>
<li>
<a href="#JOIN+%28inner%29">JOIN (inner) </a>
</li>
<li>
<a href="#JOIN+%28outer%29">JOIN (outer) </a>
</li>
<li>
<a href="#LIMIT">LIMIT </a>
</li>
<li>
<a href="#LOAD">LOAD </a>
</li>
<li>
<a href="#ORDER">ORDER</a>
</li>
<li>
<a href="#SAMPLE">SAMPLE</a>
</li>
<li>
<a href="#SPLIT">SPLIT</a>
</li>
<li>
<a href="#STORE">STORE </a>
</li>
<li>
<a href="#STREAM">STREAM</a>
</li>
<li>
<a href="#UNION">UNION</a>
</li>
</ul>
</li>
<li>
<a href="#Diagnostic+Operators">Diagnostic Operators</a>
<ul class="minitoc">
<li>
<a href="#DESCRIBE">DESCRIBE</a>
</li>
<li>
<a href="#DUMP">DUMP</a>
</li>
<li>
<a href="#EXPLAIN">EXPLAIN</a>
</li>
<li>
<a href="#ILLUSTRATE">ILLUSTRATE</a>
</li>
</ul>
</li>
<li>
<a href="#UDF+Statements">UDF Statements</a>
<ul class="minitoc">
<li>
<a href="#DEFINE">DEFINE</a>
</li>
<li>
<a href="#Example%3A+DEFINE+with+STREAM">Example: DEFINE with STREAM</a>
</li>
<li>
<a href="#Examples%3A+Logging">Examples: Logging</a>
</li>
<li>
<a href="#REGISTER">REGISTER</a>
</li>
</ul>
</li>
<li>
<a href="#Eval+Functions">Eval Functions</a>
<ul class="minitoc">
<li>
<a href="#AVG">AVG</a>
</li>
<li>
<a href="#CONCAT">CONCAT</a>
</li>
<li>
<a href="#COUNT">COUNT</a>
</li>
<li>
<a href="#COUNT_STAR">COUNT_STAR</a>
</li>
<li>
<a href="#DIFF">DIFF</a>
</li>
<li>
<a href="#IsEmpty">IsEmpty</a>
</li>
<li>
<a href="#MAX">MAX</a>
</li>
<li>
<a href="#MIN">MIN</a>
</li>
<li>
<a href="#SIZE">SIZE</a>
</li>
<li>
<a href="#SUM">SUM</a>
</li>
<li>
<a href="#TOKENIZE">TOKENIZE</a>
</li>
</ul>
</li>
<li>
<a href="#Load%2FStore+Functions">Load/Store Functions</a>
<ul class="minitoc">
<li>
<a href="#Handling+Compression">Handling Compression</a>
</li>
<li>
<a href="#BinStorage">BinStorage</a>
</li>
<li>
<a href="#PigStorage">PigStorage</a>
</li>
<li>
<a href="#PigDump">PigDump</a>
</li>
<li>
<a href="#TextLoader">TextLoader</a>
</li>
</ul>
</li>
<li>
<a href="#Shell+Commands">Shell Commands</a>
<ul class="minitoc">
<li>
<a href="#fs">fs</a>
</li>
</ul>
</li>
<li>
<a href="#File+Commands">File Commands</a>
<ul class="minitoc">
<li>
<a href="#cat">cat</a>
</li>
<li>
<a href="#cd">cd</a>
</li>
<li>
<a href="#copyFromLocal">copyFromLocal</a>
</li>
<li>
<a href="#copyToLocal">copyToLocal</a>
</li>
<li>
<a href="#cp">cp</a>
</li>
<li>
<a href="#ls">ls</a>
</li>
<li>
<a href="#mkdir">mkdir</a>
</li>
<li>
<a href="#mv">mv</a>
</li>
<li>
<a href="#pwd">pwd</a>
</li>
<li>
<a href="#rm">rm</a>
</li>
<li>
<a href="#rmf">rmf</a>
</li>
</ul>
</li>
<li>
<a href="#Utility+Commands">Utility Commands</a>
<ul class="minitoc">
<li>
<a href="#exec">exec</a>
</li>
<li>
<a href="#help">help</a>
</li>
<li>
<a href="#kill">kill</a>
</li>
<li>
<a href="#quit">quit</a>
</li>
<li>
<a href="#run">run</a>
</li>
<li>
<a href="#set">set</a>
</li>
</ul>
</li>
</ul>
</div>

   
   <!-- Overview -->
   
<a name="N1000B"></a><a name="Overview"></a>
<h2 class="h3">Overview</h2>
<div class="section">
<p>
Use this manual together with <a href="piglatin_ref1.html">Pig Latin Reference Manual 1</a>. 
   </p>
<p>
Also, be sure to review the information in the <a href="cookbook.html">Pig Cookbook</a>. 
</p>
<a name="N10021"></a><a name="Conventions"></a>
<h3 class="h4">Conventions</h3>
<p>Conventions for the syntax and code examples in the Pig Latin Reference Manual are described here.</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>Convention</p>
            
</td>
            <td>
               
<p>Description</p>
            
</td>
            <td>
               
<p>Example</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>( )</p>
            
</td>
            <td>
               
<p>Parentheses enclose one or more items.</p>
               
<p>Parentheses are also used to indicate the tuple data type.</p>
            
</td>
            <td>
               
<p>Multiple items:</p>
               
<p>(1, abc, (2,4,6) )</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>[ ]</p>
            
</td>
            <td>
               
<p>Straight brackets enclose one or more optional items.</p>
               
<p>Straight brackets are also used to indicate the map data type. In this case &lt;&gt; is used to indicate optional items.</p>
            
</td>
            <td>
               
<p>Optional items:</p>
               
<p>[INNER | OUTER]</p>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>{ }</p>
            
</td>
            <td>
               
<p>Curly brackets enclose two or more items, one of which is required. </p>
               
<p>Curly brackets also used to indicate the bag data type. In this case &lt;&gt; is used to indicate required items.</p>
            
</td>
            <td>
               
<p>Two items, one required:</p>
               
<p>{ gen_blk | nested_gen_blk }</p>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>&hellip;</p>
            
</td>
            <td>
               
<p>Horizontal ellipsis points indicate that you can repeat a portion of the code.</p>
            
</td>
            <td>
               
<p>Pig Latin syntax statement:</p>
               
<p>cat path [path &hellip;]</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>UPPERCASE</p>
               
<p></p>
               
<p>lowercase</p>
            
</td>
            <td>
               
<p>In general, uppercase type indicates elements the system supplies.</p>
               
<p>In general, lowercase type indicates elements that you supply.</p>
               
<p>Note: The names (aliases) of relations and fields are case sensitive. The names of Pig Latin functions are case sensitive. All other Pig Latin keywords are case insensitive.</p>
            
</td>
            <td>
               
<p>Pig Latin statement:</p>
               
<p>A = LOAD 'data' AS (f1:int);</p>
               
<p></p>
               
<ul>
                  
<li>
                     
<p>LOAD, AS supplied BY system</p>
                  
</li>
                  
<li>
                     
<p>A, f1 are names (aliases)</p>
                  
</li>
                  
<li>
                     
<p>data supplied by you</p>
                  
</li>
               
</ul>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>italics</p>
            
</td>
            <td>
               
<p>Italic type indicates placeholders or variables for which you must supply values.</p>
            
</td>
            <td>
               
<p>Pig Latin syntax:</p>
               
<p>alias = LIMIT alias &nbsp;n;</p>
               
<p></p>
               
<p>You supply the values for placeholder alias and variable n.</p>
            
</td>
         
</tr>
   
</table>
<a name="N10109"></a><a name="Keywords"></a>
<h3 class="h4">Keywords</h3>
<p>Pig keywords are listed here.</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
        
    
         
<tr>
            
<td> 
<p>-- A </p> 
</td>
            <td> 
<p>and, any, all, arrange, as, asc, AVG</p> 
</td>
         
</tr>      
      
         
<tr>
            
<td> 
<p>-- B </p> 
</td>
            <td> 
<p>bag, BinStorage, by, bytearray </p> 
</td>
         
</tr>   

         
<tr>
            
<td> 
<p>-- C </p> 
</td>
            <td> 
<p>cache, cat, cd, chararray, cogroup, CONCAT, copyFromLocal, copyToLocal, COUNT, cp, cross</p> 
</td>
         
</tr>
         
         
<tr>
            
<td> 
<p>-- D </p> 
</td>
            <td> 
<p>%declare, %default, define, desc, describe, DIFF, distinct, double, du, dump</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- E </p> 
</td>
            <td> 
<p>e, E, eval, exec, explain</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- F </p> 
</td>
            <td> 
<p>f, F, filter, flatten, float, foreach, full</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- G </p> 
</td>
            <td> 
<p>generate, group</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- H </p> 
</td>
            <td> 
<p>help</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- I </p> 
</td>
            <td> 
<p>if, illustrate, inner, input, int, into, is</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- J </p> 
</td>
            <td> 
<p>join</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- K </p> 
</td>
            <td> 
<p>kill</p> 
</td>
         
</tr>   
         
         
<tr>
            
<td> 
<p>-- L </p> 
</td>
            <td> 
<p>l, L, left, limit, load, long, ls</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- M </p> 
</td>
            <td> 
<p>map, matches, MAX, MIN, mkdir, mv </p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- N </p> 
</td>
            <td> 
<p>not, null</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- O </p> 
</td>
            <td> 
<p>or, order, outer, output</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- P </p> 
</td>
            <td> 
<p>parallel, pig, PigDump, PigStorage, pwd</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- Q </p> 
</td>
            <td> 
<p>quit</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- R </p> 
</td>
            <td> 
<p>register, right, rm, rmf, run</p> 
</td>
         
</tr>  

         
<tr>
            
<td> 
<p>-- S </p> 
</td>
            <td> 
<p>sample, set, ship, SIZE, split, stderr, stdin, stdout, store, stream, SUM</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- T </p> 
</td>
            <td> 
<p>TextLoader, TOKENIZE, through, tuple</p> 
</td>
         
</tr>  
         
         
<tr>
            
<td> 
<p>-- U </p> 
</td>
            <td> 
<p>union, using</p> 
</td>
         
</tr>  

         
<tr>
            
<td> 
<p>-- V, W, X, Y, Z </p> 
</td>
            <td> 
<p> 
</p> 
</td>
         
</tr>  
                    
        
<tr>
            
<td> 
<p>-- Symbols</p> 
</td>
            <td> 
<p>= =   !=   &lt;  &gt; &nbsp; &lt;= &nbsp; &gt;=   +   -   *   /   %   ?   $   .   #   ::   ( )   [ ]   { } </p> 
</td>
         
</tr> 
            
      
   
</table>
</div>
   
<!-- DATA TYPES AND MORE-->


<a name="N10272"></a><a name="Data+Types+and+More"></a>
<h2 class="h3">Data Types and More</h2>
<div class="section">
<a name="N1027A"></a><a name="Relations%2C+Bags%2C+Tuples%2C+Fields"></a>
<h3 class="h4">Relations, Bags, Tuples, Fields</h3>
<p>
<a href="piglatin_ref1.html#Pig+Latin+Statements">Pig Latin statements</a> work with relations. A relation can be defined as follows:</p>
<ul>
      
<li>
         
<p>A relation is a bag (more specifically, an outer bag).</p>
      
</li>
      
<li>
         
<p>A bag is a collection of tuples. </p>
      
</li>
      
<li>
         
<p>A tuple is an ordered set of fields.</p>
      
</li>
      
<li>
         
<p>A field is a piece of data.</p>
      
</li>
   
</ul>
<p></p>
<p>A Pig relation is a bag of tuples. A Pig relation is similar to a table in a relational database, where the tuples in the bag correspond to the rows in a table. Unlike a relational table, however, Pig relations don't require that every tuple contain the same number of fields or that the fields in the same position (column) have the same type.</p>
<p>Also note that relations are unordered which means there is no guarantee that tuples are processed in any particular order. Furthermore, processing may be parallelized in which case tuples are not processed according to any total ordering.</p>
<a name="N102A9"></a><a name="Referencing+Relations"></a>
<h4>Referencing Relations</h4>
<p>Relations are referred to by name (or alias). Names are assigned by you as part of the Pig Latin statement. In this example the name (alias) of the relation is A.</p>
<pre class="code">
A = LOAD 'student' USING PigStorage() AS (name:chararray, age:int, gpa:float);
DUMP A;
(John,18,4.0F)
(Mary,19,3.8F)
(Bill,20,3.9F)
(Joe,18,3.8F)
</pre>
<a name="N102B5"></a><a name="Referencing+Fields"></a>
<h4>Referencing Fields</h4>
<p>Fields are referred to by positional notation or by name (alias). </p>
<ul>
      
<li>
         
<p>Positional notation is generated by the system. Positional notation is indicated with the dollar sign ($) and begins with zero (0); for example, $0, $1, $2. </p>
      
</li>
      
<li>
         
<p>Names are assigned by you using schemas (or, in the case of the GROUP operator and some functions, by the system). You can use any name that is not a Pig keyword; for example, f1, f2, f3 or a, b, c or name, age, gpa.</p>
      
</li>
   
</ul>
<p>Given relation A above, the three fields are separated out in this table. </p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>First Field</p>
            
</td>
            <td>
               
<p>Second Field</p>
            
</td>
            <td>
               
<p>Third Field </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Data type</p>
            
</td>
            <td>
               
<p>chararray</p>
            
</td>
            <td>
               
<p>int</p>
            
</td>
            <td>
               
<p>float</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Positional notation (generated by system) </p>
            
</td>
            <td>
               
<p>$0</p>
            
</td>
            <td>
               
<p>$1</p>
            
</td>
            <td>
               
<p>$2</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Possible name (assigned by you using a schema)</p>
            
</td>
            <td>
               
<p>name</p>
            
</td>
            <td>
               
<p>age</p>
            
</td>
            <td>
               
<p>gpa</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Field value (for the first tuple)</p>
            
</td>
            <td>
               
<p>John</p>
            
</td>
            <td>
               
<p>18</p>
            
</td>
            <td>
               
<p>4.0</p>
            
</td>
         
</tr>
   
</table>
<p>As shown in this example when you assign names to fields you can still refer to the fields using positional notation. However, for debugging purposes and ease of comprehension, it is better to use names.</p>
<pre class="code">
A = LOAD 'student' USING PigStorage() AS (name:chararray, age:int, gpa:float);
X = FOREACH A GENERATE name,$2;
DUMP X;
(John,4.0F)
(Mary,3.8F)
(Bill,3.9F)
(Joe,3.8F)
</pre>
<p>In this example an error is generated because the requested column ($3) is outside of the declared schema (positional notation begins with $0). Note that the error is caught before the statements are executed.</p>
<pre class="code">
A = LOAD 'data' AS (f1:int,f2:int,f3:int);
B = FOREACH A GENERATE $3;
DUMP B;
2009-01-21 23:03:46,715 [main] ERROR org.apache.pig.tools.grunt.GruntParser - java.io.IOException: 
Out of bound access. Trying to access non-existent  : 3. Schema {f1: bytearray,f2: bytearray,f3: bytearray} has 3 column(s). 
<em>etc ...</em>
</pre>
<a name="N10368"></a><a name="Referencing+Fields+that+are+Complex+Data+Types"></a>
<h4>Referencing Fields that are Complex Data Types</h4>
<p>As noted, the fields in a tuple can be any data type, including the complex data types: bags, tuples, and maps. </p>
<ul>
      
<li>
         
<p>Use the schemas for complex data types to name fields that are complex data types. </p>
      
</li>
      
<li>
         
<p>Use the dereference operators to reference and work with fields that are complex data types.</p>
      
</li>
   
</ul>
<p>In this example the data file contains tuples. A schema for complex data types (in this case, tuples) is used to load the data. Then, dereference operators (the dot in t1.t1a and t2.$0) are used to access the fields in the tuples. Note that when you assign names to fields you can still refer to these fields using positional notation.</p>
<pre class="code">
cat data;
(3,8,9) (4,5,6)
(1,4,7) (3,7,5)
(2,5,8) (9,5,8)

A = LOAD 'data' AS (t1:tuple(t1a:int, t1b:int,t1c:int),t2:tuple(t2a:int,t2b:int,t2c:int));

DUMP A;
((3,8,9),(4,5,6))
((1,4,7),(3,7,5))
((2,5,8),(9,5,8))

X = FOREACH A GENERATE t1.t1a,t2.$0;

DUMP X;
(3,4)
(1,3)
(2,9)
</pre>
<a name="N10387"></a><a name="Data+Types"></a>
<h3 class="h4">Data Types</h3>
<a name="N1038D"></a><a name="Simple+and+Complex"></a>
<h4>Simple and Complex</h4>
<p></p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>Simple Data Types</p>
            
</td>
            <td>
               
<p>Description</p>
            
</td>
            <td>
               
<p>Example </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Scalars</p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>int</p>
            
</td>
            <td>
               
<p>Signed 32-bit integer</p>
            
</td>
            <td>
               
<p>10</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>long</p>
            
</td>
            <td>
               
<p>Signed 64-bit integer</p>
            
</td>
            <td>
               
<p>Data: &nbsp; &nbsp; 10L or 10l </p>
               
<p>Display: 10L </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>float</p>
            
</td>
            <td>
               
<p>32-bit floating point</p>
            
</td>
            <td>
               
<p>Data: &nbsp; &nbsp; 10.5F or 10.5f or 10.5e2f or 10.5E2F</p>
               
<p>Display: 10.5F or 1050.0F</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>double</p>
            
</td>
            <td>
               
<p>64-bit floating point</p>
            
</td>
            <td>
               
<p>Data: &nbsp; &nbsp; 10.5 or 10.5e2 or 10.5E2</p>
               
<p>Display: 10.5 or 1050.0</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Arrays</p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray</p>
            
</td>
            <td>
               
<p>Character array (string) in Unicode UTF-8 format</p>
            
</td>
            <td>
               
<p>hello world</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray</p>
            
</td>
            <td>
               
<p>Byte array (blob)</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Complex Data Types</p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple</p>
            
</td>
            <td>
               
<p>An ordered set of fields.</p>
            
</td>
            <td>
               
<p>(19,2)</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bag</p>
            
</td>
            <td>
               
<p>An collection of tuples.</p>
            
</td>
            <td>
               
<p>{(19,2), (18,1)}</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>map</p>
            
</td>
            <td>
               
<p>A set of key value pairs.</p>
            
</td>
            <td>
               
<p>[open#apache]</p>
            
</td>
         
</tr>
   
</table>
<p>Note the following general observations about data types:</p>
<ul>
      
<li>
         
<p>Use schemas to assign types to fields. &nbsp;If you don't assign types, fields default to type bytearray and implicit conversions are applied to the data depending on the context in which that data is used. For example, in relation B, f1 is converted to integer because 5 is integer. In relation C, f1 and f2 are converted to double because we don't know the type of either f1 or f2.</p>
      
<pre class="code">
A = LOAD 'data' AS (f1,f2,f3);
B = FOREACH A GENERATE f1 + 5;
C = FOREACH A generate f1 + f2;
</pre>
      
</li>
   
</ul>
<ul>
      
<li>
         
<p>If a schema is defined as part of a load statement, the load function will attempt to enforce the schema. If the data does not conform to the schema, the loader will generate a null value or an error.</p>
      
<pre class="code">
A = LOAD 'data' AS (name:chararray, age:int, gpa:float);
</pre>
      
</li>
   
</ul>
<p></p>
<ul>
      
<li>
         
<p>If an explicit cast is not supported, an error will occur. For example, you cannot cast a chararray to int.</p>
         
<pre class="code">
A = LOAD 'data' AS (name:chararray, age:int, gpa:float);
B = FOREACH A GENERATE (int)name;

<em>This will cause an error &hellip;</em>
</pre>
      
</li>
   
</ul>
<p></p>
<ul>
      
<li>
         
<p>If Pig cannot resolve incompatible types through implicit casts, an error will occur. For example, you cannot add chararray and float (see the Types Table for addition and subtraction).</p>
      
<pre class="code">
A = LOAD 'data' AS (name:chararray, age:int, gpa:float);
B = FOREACH A GENERATE name + gpa;

<em>This will cause an error &hellip;</em>
</pre>
      
</li>
   
</ul>
<a name="N104E7"></a><a name="Tuple"></a>
<h4>Tuple</h4>
<p>A tuple is an ordered set of fields.</p>
<a name="N104F0"></a><a name="Syntax"></a>
<h5>Syntax </h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>( field [, field &hellip;] ) &nbsp;</p>
            
</td>
         
</tr>
   
</table>
<a name="N10502"></a><a name="Terms"></a>
<h5>Terms</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>( &nbsp;)</p>
            
</td>
            <td>
               
<p>A tuple is enclosed in parentheses ( ).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>field</p>
            
</td>
            <td>
               
<p>A piece of data. A field can be any data type (including tuple and bag).</p>
            
</td>
         
</tr>
   
</table>
<a name="N10529"></a><a name="Usage"></a>
<h5>Usage</h5>
<p>You can think of a tuple as a row with one or more fields, where each field can be any data type and any field may or may not have data. If a field has no data, then the following happens:</p>
<ul>
      
<li>
         
<p>In a load statement, the loader will inject null into the tuple. The actual value that is substituted for null is loader specific; for example, PigStorage substitutes an empty field for null.</p>
      
</li>
      
<li>
         
<p>In a non-load statement, if a requested field is missing from a tuple, Pig will inject null.</p>
      
</li>
   
</ul>
<a name="N10541"></a><a name="Example"></a>
<h5>Example</h5>
<p>In this example the tuple contains three fields.</p>
<pre class="code">(John,18,4.0F)</pre>
<a name="N1054E"></a><a name="Bag"></a>
<h4>Bag</h4>
<p>A bag is a collection of tuples.</p>
<a name="N10557"></a><a name="Syntax%3A+Inner+bag"></a>
<h5>Syntax: Inner bag</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>{ tuple [, tuple &hellip;] }</p>
            
</td>
         
</tr>
   
</table>
<a name="N10568"></a><a name="Terms-N10568"></a>
<h5>Terms</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>{ &nbsp;}</p>
            
</td>
            <td>
               
<p>An inner bag is enclosed in curly brackets { }.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple</p>
            
</td>
            <td>
               
<p>A tuple.</p>
            
</td>
         
</tr>
   
</table>
<a name="N1058F"></a><a name="Usage-N1058F"></a>
<h5>Usage </h5>
<p>Note the following about bags:</p>
<ul>
      
<li>
         
<p>A bag can have duplicate tuples.</p>
      
</li>
      
<li>
         
<p>A bag can have tuples with differing numbers of fields. However, if Pig tries to access a field that does not exist, a null value is substituted.</p>
      
</li>
      
<li>
         
<p>A bag can have tuples with fields that have different data types. However, for Pig to effectively process bags, the schemas of the tuples within those bags should be the same. For example, if half of the tuples include chararray fields and while the other half include float fields, only half of the tuples will participate in any kind of computation because the chararray fields will be converted to null.</p>
         
<p></p>
         
<p>Bags have two forms: outer bag (or relation) and inner bag.</p>
      
</li>
   
</ul>
<a name="N105B2"></a><a name="Example%3A+Outer+Bag"></a>
<h5>Example: Outer Bag</h5>
<p>In this example A is a relation or bag of tuples. You can think of this bag as an outer bag.</p>
<pre class="code">
A = LOAD 'data' as (f1:int, f2:int, f3;int);
DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
</pre>
<a name="N105BF"></a><a name="Example%3A+Inner+Bag"></a>
<h5>Example: Inner Bag</h5>
<p>Now, suppose we group relation A by the first field to form relation X. </p>
<p>In this example X is a relation or bag of tuples. The tuples in relation X have two fields. The first field is type int. The second field is type bag; you can think of this bag as an inner bag.</p>
<pre class="code">
X = GROUP A BY f1;
DUMP X;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(8,{(8,3,4)})
</pre>
<a name="N105CF"></a><a name="Map"></a>
<h4>Map</h4>
<p>A map is a set of key value pairs.</p>
<a name="N105D8"></a><a name="Syntax+%28%3C%3E+denotes+optional%29"></a>
<h5>Syntax (&lt;&gt; denotes optional)</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>[ key#value &lt;, key#value &hellip;&gt; ]</p>
            
</td>
         
</tr>
   
</table>
<a name="N105EA"></a><a name="Terms-N105EA"></a>
<h5>Terms</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>[ ]</p>
            
</td>
            <td>
               
<p>Maps are enclosed in straight brackets [ ].</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>#</p>
            
</td>
            <td>
               
<p>Key value pairs are separated by the pound sign #.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>key</p>
            
</td>
            <td>
               
<p>Must be chararray data type. Must be a unique value.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>value</p>
            
</td>
            <td>
               
<p>Any data type.</p>
            
</td>
         
</tr>
   
</table>
<a name="N1062F"></a><a name="Usage-N1062F"></a>
<h5>Usage</h5>
<p>Key values within a relation must be unique.</p>
<a name="N10638"></a><a name="Example-N10638"></a>
<h5>Example</h5>
<p>In this example the map includes two key value pairs.</p>
<pre class="code">[name#John,phone#5551212]</pre>
<a name="N10645"></a><a name="Nulls"></a>
<h3 class="h4">Nulls</h3>
<p>In Pig Latin, nulls are implemented using the SQL definition of null as unknown or non-existent. Nulls can occur naturally in data or can be the result of an operation. </p>
<a name="N1064E"></a><a name="Nulls+and+Operators"></a>
<h4>Nulls and Operators</h4>
<p>Pig Latin operators interact with nulls as shown in this table.</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>Operator </p>
            
</td>
            <td>
               
<p>Interaction </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Comparison operators:</p>
               
<p>==, !=</p>
               
<p>&gt;, &lt;</p>
               
<p>&gt;=, &lt;=</p>
            
</td>
            <td>
               
<p>If either sub-expression is null, the result is null.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Comparison operator:</p>
               
<p>matches </p>
            
</td>
            <td>
               
<p>If either the string being matched against or the string defining the match is null, the result is null.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Arithmetic operators:</p>
               
<p>&nbsp;+ , -, *, /</p>
               
<p>% modulo</p>
               
<p>? bincond</p>
            
</td>
            <td>
               
<p>If either sub-expression is null, the resulting expression is null.</p>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Null operator:</p>
               
<p>is null </p>
            
</td>
            <td>
               
<p>If the tested value is null, returns true; otherwise, returns false.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Null operator:</p>
               
<p>is not null</p>
            
</td>
            <td>
               
<p>If the tested value is not null, returns true; otherwise, returns false.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Dereference operators:</p>
               
<p>tuple (.) or map (#)</p>
            
</td>
            <td>
               
<p>If the de-referenced tuple or map is null, returns null.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Cast operator</p>
            
</td>
            <td>
               
<p>Casting a null from one type to another type results in a null.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Functions:</p>
               
<p>AVG, MIN, MAX, SUM</p>
            
</td>
            <td>
               
<p>These functions ignore nulls. </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Function:</p>
               
<p>COUNT</p>
            
</td>
            <td>
               
<p>This function counts all values, including nulls.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Function:</p>
               
<p>CONCAT</p>
            
</td>
            <td>
               
<p>If either sub-expression is null, the resulting expression is null.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Function:</p>
               
<p>SIZE</p>
            
</td>
            <td>
               
<p>If the tested object is null, returns null.</p>
            
</td>
         
</tr>
   
</table>
<p>For Boolean sub-expressions, note the results when nulls are used with these operators:</p>
<ul>
      
<li>
         
<p>FILTER operator &ndash; If a filter expression results in null value, the filter does not pass them through (if X is null, !X is also null, and the filter will reject both).</p>
      
</li>
      
<li>
         
<p>Bincond operator &ndash; If a Boolean sub-expression results in null value, the resulting expression is null (see the interactions above for Arithmetic operators)</p>
      
</li>
   
</ul>
<a name="N1074D"></a><a name="Nulls+and+Constants"></a>
<h4>Nulls and Constants</h4>
<p>Nulls can be used as constant expressions in place of expressions of any type.</p>
<p>In this example a and null are projected.</p>
<pre class="code">
A = LOAD 'data' AS (a, b, c).
B = FOREACH A GENERATE a, null;
</pre>
<p>In this example of an outer join, if the join key is missing from a table it is replaced by null.</p>
<pre class="code">
A = LOAD 'student' AS (name: chararray, age: int, gpa: float);
B = LOAD 'votertab10k' AS (name: chararray, age: int, registration: chararray, donation: float);
C = COGROUP A BY name, B BY name;
D = FOREACH C GENERATE FLATTEN((IsEmpty(A) ? null : A)), FLATTEN((IsEmpty(B) ? null : B));
</pre>
<p>Like any other expression, null constants can be implicitly or explicitly cast. </p>
<p>In this example both a and null will be implicitly cast to double.</p>
<pre class="code">
A = LOAD 'data' AS (a, b, c).
B = FOREACH A GENERATE a + null;
</pre>
<p>In this example &nbsp;both a and null will be cast to int, a implicitly, and null explicitly.</p>
<pre class="code">
A = LOAD 'data' AS (a, b, c).
B = FOREACH A GENERATE a + (int)null;
</pre>
<a name="N10772"></a><a name="Operations+That+Produce+Nulls"></a>
<h4>Operations That Produce Nulls</h4>
<p>As noted, nulls can be the result of an operation. These operations can produce null values: </p>
<ul>
      
<li>
         
<p>Division by zero</p>
      
</li>
      
<li>
         
<p>Returns from user defined functions (UDFs) </p>
      
</li>
      
<li>
         
<p>Dereferencing a field that does not exist.</p>
      
</li>
      
<li>
         
<p>Dereferencing a key that does not exist in a map. For example, given a map, info, containing [name#john, phone#5551212] if a user tries to use info#address a null is returned.</p>
      
</li>
      
<li>
         
<p>Accessing a field that does not exist in a tuple.</p>
      
</li>
   
</ul>
<a name="N1079C"></a><a name="Example%3A+Accessing+a+field+that+does+not+exist+in+a+tuple"></a>
<h5>Example: Accessing a field that does not exist in a tuple</h5>
<p>In this example nulls are injected if fields do not have data.</p>
<pre class="code">
cat data;
    2   3
4   
7   8   9

A = LOAD 'data' AS (f1:int,f2:int,f3:int)

DUMP A;
(,2,3)
(4,,)
(7,8,9)

B = FOREACH A GENERATE f1,f2;

DUMP B;
(,2)
(4,)
(7,8)
</pre>
<a name="N107A9"></a><a name="Nulls+and+Load+Functions"></a>
<h4>Nulls and Load Functions</h4>
<p>
As noted, nulls can occur naturally in the data. If nulls are part of the data, it is the responsibility of the load function to handle them correctly. Keep in mind that what is considered a null value is loader-specific; however, the load function should always communicate null values to Pig by producing Java nulls.</p>
<p>The Pig Latin load functions (for example, PigStorage and TextLoader) produce null values wherever data is missing. For example, empty strings (chararrays) are not loaded; instead, they are replaced by nulls.</p>
<p>PigStorage is the default load function for the LOAD operator. In this example the is not null operator is used to filter names with null values.</p>
<pre class="code">
A = LOAD 'student' AS (name, age, gpa); 
B = FILTER A BY name is not null;
</pre>
<a name="N107BC"></a><a name="Constants"></a>
<h3 class="h4">Constants</h3>
<p>Pig provides constant representations for all data types except bytearrays.</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>Constant Example</p>
            
</td>
            <td>
               
<p>Notes</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Simple Data Types</p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Scalars</p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>int</p>
            
</td>
            <td>
               
<p>19</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>long</p>
            
</td>
            <td>
               
<p>19L</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>float</p>
            
</td>
            <td>
               
<p>19.2F or 1.92e2f</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>double</p>
            
</td>
            <td>
               
<p>19.2 or 1.92e2</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Arrays </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray</p>
            
</td>
            <td>
               
<p>'hello world'</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray</p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>Not applicable.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>Complex Data Types</p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple</p>
            
</td>
            <td>
               
<p>(19, 2, 1)</p>
            
</td>
            <td>
               
<p>A constant in this form creates a tuple.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bag</p>
            
</td>
            <td>
               
<p>{ (19, 2), (1, 2) }</p>
            
</td>
            <td>
               
<p>A constant in this form creates a bag.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>map</p>
            
</td>
            <td>
               
<p>[ 'name' # 'John', 'ext' # 5555 ]</p>
            
</td>
            <td>
               
<p>A constant in this form creates a map.</p>
            
</td>
         
</tr>
   
</table>
<p></p>
<p>Please note the following:</p>
<ul>
      
<li>
         
<p>On UTF-8 systems you can specify string constants consisting of printable ASCII characters such as 'abc'; you can specify control characters such as '\t'; and, you can specify a character in Unicode by starting it with '\u', for instance, '\u0001' represents Ctrl-A in hexadecimal (see Wikipedia <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>, <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a>, and <a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a>). In theory, you should be able to specify non-UTF-8 constants on non-UTF-8 systems but as far as we know this has not been tested.</p>
      
</li>
      
<li>
         
<p>To specify a long constant, l or L must be appended to the number (for example, 12345678L). If the l or L is not specified, but the number is too large to fit into an int, the problem will be detected at parse time and the processing is terminated. </p>
      
</li>
      
<li>
         
<p>Any numeric constant with decimal point (for example, 1.5) and/or exponent (for example, 5e+1) is treated as double unless it ends with f or F in which case it is assigned type float (for example, &nbsp;1.5f). </p>
      
</li>
   
</ul>
<p></p>
<p>The data type definitions for tuples, bags, and maps apply to constants:</p>
<ul>
      
<li>
         
<p>A tuple can contain fields of any data type</p>
      
</li>
      
<li>
         
<p>A bag is a collection of tuples</p>
      
</li>
      
<li>
         
<p>A map key must be a scalar; a map value can be any data type</p>
      
</li>
   
</ul>
<p></p>
<p>Complex constants (either with or without values) can be used in the same places scalar constants can be used; that is, in FILTER and GENERATE statements.</p>
<pre class="code">
A = LOAD 'data' USING MyStorage() AS (T: tuple(name:chararray, age: int));
B = FILTER A BY T == ('john', 25);
D = FOREACH B GENERATE T.name, [25#5.6], {(1, 5, 18)};
</pre>
<a name="N10928"></a><a name="Expressions"></a>
<h3 class="h4">Expressions</h3>
<p>In Pig Latin, expressions are language constructs used with the FILTER, FOREACH, GROUP, and SPLIT operators as well as the eval functions.</p>
<p>Expressions are written in conventional mathematical infix notation and are adapted to the UTF-8 character set. Depending on the context, expressions can include:</p>
<ul>
      
<li>
         
<p>Any Pig data type (simple data types, complex data types)</p>
      
</li>
      
<li>
         
<p>Any Pig operator (arithmetic, comparison, null, boolean, dereference, sign, and cast)</p>
      
</li>
      
<li>
         
<p>Any Pig built-in function.</p>
      
</li>
      
<li>
         
<p>Any user-defined function (UDF) written in Java. </p>
       
</li>
        
</ul>
<p></p>
<p>In Pig Latin,</p>
<ul>
       
<li>
         
<p>An arithmetic expression could look like this:</p>
         
<pre class="code">
X = GROUP A BY f2*f3;
</pre>
      
</li>

      
<li>
         
<p></p>
         
<p>A string expression could look like this, where a and b are both chararrays:</p>
         
<pre class="code">
X = FOREACH A GENERATE CONCAT(a,b);
</pre>
      
</li>

      
<li>
         
<p></p>
         
<p>A boolean expression could look like this:</p>
         
<pre class="code">
X = FILTER A BY (f1==8) OR (NOT (f2+f3 &gt; f1));
</pre>
      
</li>
   
</ul>
<a name="N10976"></a><a name="fexp"></a>
<h4>Field expressions</h4>
<p>Field expressions represent a field or a dereference operator applied to a field. See <a href="#deref">Dereference Operators</a> for more details.</p>
<a name="N10984"></a><a name="sexp"></a>
<h4>Star expression</h4>
<p>The star symbol, *, can be used to represent all the fields of a tuple. It is equivalent to writing out the fields explicitly. In the following example the definition of B and C are exactly the same, and MyUDF will be invoked with exactly the same arguments in both cases.</p>
<pre class="code">
A = LOAD 'data' USING MyStorage() AS (name:chararray, age: int);
B = FOREACH A GENERATE *, MyUDF(name, age);
C = FOREACH A GENERATE name, age, MyUDF(*);
          </pre>
<p>A common error when using the star expression is the following:</p>
<pre class="code">
G = GROUP A BY $0;
C = FOREACH G GENERATE COUNT(*)
          </pre>
<p>In this example, the programmer really wants to count the number of elements in the bag in the second field: COUNT($1).</p>
<a name="N1099A"></a><a name="bexp"></a>
<h4>Boolean expressions</h4>
<p>Boolean expressions can be made up of UDFs that return a boolean value or boolean operators (see <a href="#boolops">Boolean Operators</a>). 
          </p>
<a name="N109A8"></a><a name="texp"></a>
<h4>Tuple expressions</h4>
<p>Tuple expressions form subexpressions into tuples. The tuple expression has the form (expression [, expression &hellip;]), where expression is a general expression. The simplest tuple expression is the star expression, which represents all fields.
          </p>
<a name="N109B2"></a><a name="gexp"></a>
<h4>General expressions</h4>
<p>General expressions can be made up of UDFs and almost any operator. Since Pig does not consider boolean a base type, the result of a general expression cannot be a boolean. Field expressions are the simpliest general expressions.
          </p>
<a name="N109BD"></a><a name="Schemas"></a>
<h3 class="h4">Schemas</h3>
<p>Schemas enable you to assign names to and declare types for fields. Schemas are optional but we encourage you to use them whenever possible; type declarations result in better parse-time error checking and more efficient code execution. </p>
<p>Schemas are defined using the AS keyword with the LOAD, STREAM, and FOREACH operators. If you define a schema using the LOAD operator, then it is the load function that enforces the schema (see the LOAD operator and the <a href="udf.html">Pig UDF Manual</a> for more information).</p>
<p>Note the following:</p>
<ul>
      
<li>
         
<p>You can define a schema that includes both the field name and field type.</p>
      
</li>
      
<li>
         
<p>You can define a schema that includes the field name only; in this case, the field type defaults to bytearray.</p>
      
</li>
      
<li>
         
<p>You can choose not to define a schema; in this case, the field is un-named and the field type defaults to bytearray.</p>
      
</li>
   
</ul>
<p>If you assign a name to a field, you can refer to that field using the name or by positional notation. If you don't assign a name to a field (the field is un-named) you can only refer to the field using positional notation.</p>
<p>If you assign a type to a field, you can subsequently change the type using the cast operators. If you don't assign a type to a field, the field defaults to bytearray; you can change the default type using the cast operators.</p>
<a name="N109EB"></a><a name="Schemas+with+LOAD+and+STREAM+Statements"></a>
<h4>Schemas with LOAD and STREAM Statements</h4>
<p>With LOAD and STREAM statements, the schema following the AS keyword must be enclosed in parentheses.</p>
<p>In this example the LOAD statement includes a schema definition for simple data types.</p>
<pre class="code">
A = LOAD 'data' AS (f1:int, f2:int);
</pre>
<a name="N109FB"></a><a name="Schemas+with+FOREACH+Statements"></a>
<h4>Schemas with FOREACH Statements</h4>
<p>With FOREACH statements, the schema following the AS keyword must be enclosed in parentheses when the FLATTEN operator is used. Otherwise, the schema should not be enclosed in parentheses.</p>
<p>In this example the FOREACH statement includes FLATTEN and a schema for simple data types.</p>
<pre class="code">
X = FOREACH C GENERATE FLATTEN(B) AS (f1:int, f2:int, f3:int);
</pre>
<p>In this example the FOREACH statement includes a schema for simple data types.</p>
<pre class="code">
X = FOREACH A GENERATE f1+f2 AS x1:int;
</pre>
<a name="N10A11"></a><a name="Schemas+for+Simple+Data+Types"></a>
<h4>Schemas for Simple Data Types</h4>
<p>Simple data types include int, long, float, double, chararray, and bytearray.</p>
<a name="N10A1A"></a><a name="Syntax-N10A1A"></a>
<h5>Syntax</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>(alias[:type]) [, (alias[:type]) &hellip;] )</p>
            
</td>
         
</tr>
   
</table>
<a name="N10A2C"></a><a name="Terms-N10A2C"></a>
<h5>Terms</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name assigned to the field.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>type</p>
            
</td>
            <td>
               
<p>(Optional) The simple data type assigned to the field.</p>
               
<p>The alias and type are separated by a colon ( : ).</p>
               
<p>If the type is omitted, the field defaults to type bytearray.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>( , )</p>
            
</td>
            <td>
               
<p>Multiple fields are enclosed in parentheses and separated by commas.</p>
            
</td>
         
</tr>
   
</table>
<a name="N10A68"></a><a name="Examples"></a>
<h5>Examples</h5>
<p>In this example the schema defines multiple types.</p>
<pre class="code">
cat student;
John	18	4.0
Mary	19   	3.8
Bill	20   	3.9
Joe	18   	3.8

A = LOAD 'student' AS (name:chararray, age:int, gpa:float);

DESCRIBE A;
A: {name: chararray,age: int,gpa: float}

DUMP A;
(John,18,4.0F)
(Mary,19,3.8F)
(Bill,20,3.9F)
(Joe,18,3.8F)
</pre>
<p>In this example field "gpa" will default to bytearray because no type is declared. </p>
<pre class="code">
cat student;
John	18	4.0
Mary	19	3.8
Bill	20	3.9
Joe	18	3.8

A = LOAD 'data' AS (name:chararray, age:int, gpa);

DESCRIBE A;
A: {name: chararray,age: int,gpa: bytearray}

DUMP A;
(John,18,4.0)
(Mary,19,3.8)
(Bill,20,3.9)
(Joe,18,3.8)
</pre>
<a name="N10A7B"></a><a name="Schemas+for+Complex+Data+Types"></a>
<h4>Schemas for Complex Data Types</h4>
<p>Complex data types include tuples, bags, and maps.</p>
<a name="N10A84"></a><a name="Tuple+Schema"></a>
<h4>Tuple Schema</h4>
<p>A tuple is an ordered set of fields.</p>
<a name="N10A8D"></a><a name="Syntax-N10A8D"></a>
<h5>Syntax</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias[:tuple] (alias[:type]) [, (alias[:type]) &hellip;] )</p>
            
</td>
         
</tr>
   
</table>
<a name="N10A9F"></a><a name="Terms-N10A9F"></a>
<h5>Terms</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name assigned to the tuple.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>:tuple</p>
            
</td>
            <td>
               
<p>(Optional) The data type, tuple (case insensitive).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>( )</p>
            
</td>
            <td>
               
<p>The designation for a tuple, a set of parentheses.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>alias[:type]</p>
            
</td>
            <td>
               
<p>The constituents of the tuple, where the schema definition rules for the corresponding type applies to the constituents of the tuple:</p>
               
<ul>
                  
<li>
                     
<p>alias &ndash; the name assigned to the field</p>
                  
</li>
                  
<li>
                     
<p>type (optional) &ndash; the simple or complex data type assigned to the field</p>
                  
</li>
               
</ul>
            
</td>
         
</tr>
   
</table>
<a name="N10AF3"></a><a name="Examples-N10AF3"></a>
<h5>Examples</h5>
<p>In this example the schema defines one tuple. The load statements are equivalent.</p>
<pre class="code">
cat data;
(3,8,9)
(1,4,7)
(2,5,8)

A = LOAD 'data' AS (T: tuple (f1:int, f2:int, f3:int));
A = LOAD 'data' AS (T: (f1:int, f2:int, f3:int));

DESCRIBE A;
A: {T: (f1: int,f2: int,f3: int)}

DUMP A;
((3,8,9))
((1,4,7))
((2,5,8))
</pre>
<p>In this example the schema defines two tuples.</p>
<pre class="code">
cat data;
(3,8,9) (mary,19)
(1,4,7) (john,18)
(2,5,8) (joe,18)

A = LOAD data AS (F:tuple(f1:int,f2:int,f3:int),T:tuple(t1:chararray,t2:int));

DESCRIBE A;
A: {F: (f1: int,f2: int,f3: int),T: (t1: chararray,t2: int)}

DUMP A;
((3,8,9),(mary,19))
((1,4,7),(john,18))
((2,5,8),(joe,18))
</pre>
<a name="N10B05"></a><a name="Bag+Schema"></a>
<h4>Bag Schema</h4>
<p>A bag is a collection of tuples.</p>
<a name="N10B0E"></a><a name="Syntax-N10B0E"></a>
<h5>Syntax</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias[:bag] {tuple} </p>
            
</td>
         
</tr>
   
</table>
<a name="N10B20"></a><a name="Terms-N10B20"></a>
<h5>Terms</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name assigned to the bag.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>:bag</p>
            
</td>
            <td>
               
<p>(Optional) The data type, bag (case insensitive).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>{ }</p>
            
</td>
            <td>
               
<p>The designation for a bag, a set of curly brackets.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple</p>
            
</td>
            <td>
               
<p>A tuple (see Tuple Schema).</p>
            
</td>
         
</tr>
   
</table>
<a name="N10B65"></a><a name="Examples-N10B65"></a>
<h5>Examples</h5>
<p>In this example the schema defines a bag. The two load statements are equivalent.</p>
<pre class="code">
cat data;
{(3,8,9)}
{(1,4,7)}
{(2,5,8)}

A = LOAD 'data' AS (B: bag {T: tuple(t1:int, t2:int, t3:int)});
A = LOAD 'data' AS (B: {T: (t1:int, t2:int, t3:int)});

DESCRIBE A:
A: {B: {T: (t1: int,t2: int,t3: int)}}

DUMP A;
({(3,8,9)})
({(1,4,7)})
({(2,5,8)})
</pre>
<a name="N10B72"></a><a name="Map+Schema"></a>
<h4>Map Schema</h4>
<p>A map is a set of key value pairs.</p>
<a name="N10B7B"></a><a name="Syntax+%28where+%3C%3E+means+optional%29"></a>
<h5>Syntax (where &lt;&gt; means optional)</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias&lt;:map&gt; [ ] </p>
            
</td>
         
</tr>
   
</table>
<a name="N10B8D"></a><a name="Terms-N10B8D"></a>
<h5>Terms</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name assigned to the map.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>:map</p>
            
</td>
            <td>
               
<p>(Optional) The data type, map (case insensitive).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>[ ] &nbsp; </p>
            
</td>
            <td>
               
<p>The designation for a map, a set of straight brackets [ ].</p>
            
</td>
         
</tr>
   
</table>
<a name="N10BC3"></a><a name="Example-N10BC3"></a>
<h5>Example</h5>
<p>In this example the schema defines a map. The load statements are equivalent.</p>
<pre class="code">
cat data;
[open#apache]
[apache#hadoop]

A = LOAD 'data' AS (M:map []);
A = LOAD 'data' AS (M:[]);

DESCRIBE A;
a: {M: map[ ]}

DUMP A;
([open#apache])
([apache#hadoop])
</pre>
<a name="N10BCF"></a><a name="Schemas+for+Multiple+Types"></a>
<h4>Schemas for Multiple Types</h4>
<p>You can define schemas for data that includes multiple types.</p>
<a name="N10BD8"></a><a name="Example-N10BD8"></a>
<h5>Example</h5>
<p>In this example the schema defines a tuple, bag, and map.</p>
<pre class="code">
A = LOAD 'mydata' AS (T1:tuple(f1:int, f2:int), B:bag{T2:tuple(t1:float,t2:float)}, M:map[] );

A = LOAD 'mydata' AS (T1:(f1:int, f2:int), B:{T2:(t1:float,t2:float)}, M:[] );
</pre>
<a name="N10BE5"></a><a name="Parameter+Substitution"></a>
<h3 class="h4">Parameter Substitution</h3>
<a name="N10BEB"></a><a name="Description"></a>
<h4>Description</h4>
<p>Substitute values for parameters at run time.</p>
<a name="N10BF4"></a><a name="Syntax%3A+Specifying+parameters+using+the+Pig+command+line"></a>
<h5>Syntax: Specifying parameters using the Pig command line</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>pig {&ndash;param param_name = param_value | &ndash;param_file file_name} [-debug | -dryrun] script</p>
            
</td>
         
</tr>
   
</table>
<a name="N10C06"></a><a name="Syntax%3A+Specifying+parameters+using+preprocessor+statements+in+a+Pig+script"></a>
<h5>Syntax: Specifying parameters using preprocessor statements in a Pig script</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>{%declare | %default} param_name param_value</p>
            
</td>
         
</tr>
   
</table>
<a name="N10C18"></a><a name="Terms-N10C18"></a>
<h5>Terms</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>pig</p>
            
</td>
            <td>
               
<p>Keyword</p>
               
<p>Note: exec, run, and explain also support parameter substitution.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>&ndash;param</p>
            
</td>
            <td>
               
<p>Flag. Use this option when the parameter is included in the command line.</p>
               
<p>Multiple parameters can be specified. If the same parameter is specified multiple times, the last value will be used and a warning will be generated.</p>
               
<p>Command line parameters and parameter files can be combined with command line parameters taking precedence. </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>param_name</p>
            
</td>
            <td>
               
<p>The name of the parameter.</p>
               
<p>The parameter name has the structure of a standard language identifier: it must start with a letter or underscore followed by any number of letters, digits, and underscores. </p>
               
<p>Parameter names are case insensitive. </p>
               
<p>If you pass a parameter to a script that the script does not use, this parameter is silently ignored. If the script has a parameter and no value is supplied or substituted, an error will result.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>param_value</p>
            
</td>
            <td>
               
<p>The value of the parameter. </p>
               
<p>A parameter value can take two forms:</p>
               
<ul>
                  
<li>
                     
<p>A sequence of characters enclosed in single or double quotes. In this case the unquoted version of the value is used during substitution. Quotes within the value can be escaped with the backslash character ( \ ). Single word values that don't use special characters such as % or = don't have to be quoted. </p>
                  
</li>
                  
<li>
                     
<p>A command enclosed in back ticks. </p>
                  
</li>
               
</ul>
               
<p>The value of a parameter, in either form, can be expressed in terms of other parameters as long as the values of the dependent parameters are already defined.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>&ndash;param_file</p>
            
</td>
            <td>
               
<p>Flag. Use this option when the parameter is included in a file. </p>
               
<p>Multiple files can be specified. If the same parameter is present multiple times in the file, the last value will be used and a warning will be generated. If a parameter present in multiple files, the value from the last file will be used and a warning will be generated.</p>
               
<p>Command line parameters and parameter files can be combined with command line parameters taking precedence. </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>file_name</p>
            
</td>
            <td>
               
<p>The name of a file containing one or more parameters.</p>
               
<p>A parameter file will contain one line per parameter. Empty lines are allowed. Perl-style (#) comment lines are also allowed. Comments must take a full line and # must be the first character on the line. Each parameter line will be of the form: param_name = param_value. White spaces around = are allowed but are optional.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>&ndash;debug</p>
            
</td>
            <td>
               
<p>Flag. With this option, the script is run and a fully substituted Pig script produced in the current working directory named original_script_name.substituted </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>&ndash;dryrun</p>
            
</td>
            <td>
               
<p>Flag. With this option, the script is not run and a fully substituted Pig script produced in the current working directory named original_script_name.substituted</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>script</p>
            
</td>
            <td>
               
<p>A pig script. The pig script must be the last element in the Pig command line.</p>
               
<ul>
                  
<li>
                     
<p>If parameters are specified in the Pig command line or in a parameter file, the script should include a $param_name for each para_name included in the command line or parameter file.</p>
                  
</li>
                  
<li>
                     
<p>If parameters are specified using the preprocessor statements, the script should include either %declare or %default.</p>
                  
</li>
                  
<li>
                     
<p>In the script, parameter names can be escaped with the backslash character ( \ ) in which case substitution does not take place.</p>
                  
</li>
               
</ul>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>%declare</p>
            
</td>
            <td>
               
<p>Preprocessor statement included in a Pig script.</p>
               
<p>Use to describe one parameter in terms of other parameters.</p>
               
<p>The declare statement is processed prior to running the Pig script. </p>
               
<p>The scope of a parameter value defined using declare is all the lines following the declare statement until the next declare statement that defines the same parameter is encountered.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>%default</p>
            
</td>
            <td>
               
<p>Preprocessor statement included in a Pig script.</p>
               
<p>Use to provide a default value for a parameter. The default value has the lowest priority and is used if a parameter value has not been defined by other means.</p>
               
<p>The default statement is processed prior to running the Pig script. </p>
               
<p>The scope is the same as for %declare.</p>
            
</td>
         
</tr>
   
</table>
<a name="N10D1D"></a><a name="Usage-N10D1D"></a>
<h5>Usage</h5>
<p>Parameter substitution enables you to write Pig scripts that include parameters and to supply values for these parameters at run time. For instance, suppose you have a job that needs to run every day using the current day's data. You can create a Pig script that includes a parameter for the date. Then, when you run this script you can specify or supply a value for the date parameter using one of the supported methods. </p>
<a name="N10D26"></a><a name="Specifying+Parameters"></a>
<h5>Specifying Parameters </h5>
<p>You can specify parameter names and parameter values as follows:</p>
<ul>
      
<li>
         
<p>As part of a command line.</p>
      
</li>
      
<li>
         
<p>In parameter file, as part of a command line.</p>
      
</li>
      
<li>
         
<p>With the declare statement, as part of Pig script.</p>
      
</li>
      
<li>
         
<p>With default statement, as part of a Pig script.</p>
      
</li>
   
</ul>
<a name="N10D4A"></a><a name="Precedence"></a>
<h5>Precedence</h5>
<p>Precedence for parameters is as follows:</p>
<ul>
      
<li>
         
<p>Highest - parameters defined using the declare statement</p>
      
</li>
      
<li>
         
<p>Next - parameters defined in the command line</p>
      
</li>
      
<li>
         
<p>Lowest - parameters defined in a script</p>
      
</li>
   
</ul>
<a name="N10D68"></a><a name="Processing+Order+and+Precedence"></a>
<h5>Processing Order and Precedence</h5>
<p>Parameters are processed as follows:</p>
<ul>
      
<li>
         
<p>Command line parameters are scanned in the order they are specified on the command line. </p>
      
</li>
      
<li>
         
<p>Parameter files are scanned in the order they are specified on the command line. Within each file, the parameters are processed in the order they are listed. </p>
      
</li>
      
<li>
         
<p>Declare and default preprocessors statements are processed in the order they appear in the Pig script. </p>
      
</li>
   
</ul>
<a name="N10D86"></a><a name="Example%3A+Specifying+parameters+in+the+command+line"></a>
<h5>Example: Specifying parameters in the command line</h5>
<p>Suppose we have a data file called 'mydata' and a pig script called 'myscript.pig'.</p>
<p>mydata </p>
<pre class="code">
1       2       3
4       2       1
8       3       4
</pre>
<p>myscript.pig</p>
<pre class="code">
A = LOAD '$data' USING PigStorage() AS (f1:int, f2:int, f3:int);
DUMP A;
</pre>
<p>In this example the parameter (data) and the parameter value (mydata) are specified in the command line. If the parameter name in the command line (data) and the parameter name in the script ($data) do not match, the script will not run. If the value for the parameter (mydata) is not found, an error is generated.</p>
<pre class="code">
$ pig &ndash;param data=mydata myscript.pig

(1,2,3)
(4,2,1)
(8,3,4)
</pre>
<a name="N10DA2"></a><a name="Example%3A+Specifying+parameters+using+a+parameter+file"></a>
<h5>Example: Specifying parameters using a parameter file</h5>
<p>Suppose we have a parameter file called 'myparams.'</p>
<pre class="code">
# my parameters
data1 = mydata1
cmd = `generate_name`
</pre>
<p>In this example the parameters and values are passed to the script using the parameter file.</p>
<pre class="code">
$ pig &ndash;param_file myparams script2.pig
</pre>
<a name="N10DB5"></a><a name="Example%3A+Specifying+parameters+using+the+declare+statement"></a>
<h5>Example: Specifying parameters using the declare statement</h5>
<p>In this example the command is executed and its stdout is used as the parameter value.</p>
<pre class="code">
%declare CMD 'generate_date';
A = LOAD '/data/mydata/$CMD';
B = FILTER A BY $0&gt;'5';

<em>etc...</em>
</pre>
<a name="N10DC4"></a><a name="Example%3A+Specifying+parameters+using+the+default+statement"></a>
<h5>Example: Specifying parameters using the default statement</h5>
<p>In this example the parameter (DATE) and value ('20090101') are specified in the Pig script using the default statement. If a value for DATE is not specified elsewhere, the default value 20090101 is used.</p>
<pre class="code">
%default DATE '20090101';
A = load '/data/mydata/$DATE';

<em>etc...</em>
</pre>
<a name="N10DD3"></a><a name="Examples%3A+Specifying+parameter+values+as+a+sequence+of+characters"></a>
<h5>Examples: Specifying parameter values as a sequence of characters</h5>
<p>In this example the characters (in this case, Joe's URL) can be enclosed in single or double quotes, and quotes within the sequence of characters can be escaped. </p>
<pre class="code">
%declare DES 'Joe\'s URL';
A = LOAD 'data' AS (name, description, url);
B = FILTER A BY description == '$DES';
 
<em>etc...</em>
</pre>
<p>In this example single word values that don't use special characters (in this case, mydata) don't have to be enclosed in quotes.</p>
<pre class="code">
$ pig &ndash;param data=mydata myscript.pig
</pre>
<a name="N10DE8"></a><a name="Example%3A+Specifying+parameter+values+as+a+command"></a>
<h5>Example: Specifying parameter values as a command</h5>
<p>In this example the command is enclosed in back ticks. First, the parameters mycmd and date are substituted when the declare statement is encountered. Then the resulting command is executed and its stdout is placed in the path before the load statement is run.</p>
<pre class="code">
%declare CMD '$mycmd $date';
A = LOAD '/data/mydata/$CMD';
B = FILTER A BY $0&gt;'5';
 
<em>etc...</em>
</pre>
</div>

   
<!-- ARITHMETIC OPERATORS, ETC -->

<a name="N10DFC"></a><a name="Arithmetic+Operators+and+More"></a>
<h2 class="h3">Arithmetic Operators and More</h2>
<div class="section">
<a name="N10E02"></a><a name="Arithmetic+Operators"></a>
<h3 class="h4">Arithmetic Operators</h3>
<a name="N10E08"></a><a name="Description-N10E08"></a>
<h4>Description</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>Operator</p>
            
</td>
            <td>
               
<p>Symbol</p>
            
</td>
            <td>
               
<p>&nbsp;Notes</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>addition </p>
            
</td>
            <td>
               
<p>+</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>subtraction </p>
            
</td>
            <td>
               
<p>-</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>multiplication &nbsp;</p>
            
</td>
            <td>
               
<p>*</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>division &nbsp;</p>
            
</td>
            <td>
               
<p>/</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>modulo &nbsp;</p>
            
</td>
            <td>
               
<p>%</p>
            
</td>
            <td>
               
<p>Returns the remainder of a divided by b (a%b).</p>
               
<p>Works with integral numbers (int, long). </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bincond </p>
            
</td>
            <td>
               
<p>? :</p>
            
</td>
            <td>
               
<p>(condition ? value_if_true : value_if_false) </p>
               
<p>The bincond should be enclosed in parenthesis. </p>
               
<p>The schemas for the two conditional outputs of the bincond should match.</p>
               
<p>Use expressions only (relational operators are not allowed).</p>
            
</td>
         
</tr>
   
</table>
<a name="N10EAC"></a><a name="Examples-N10EAC"></a>
<h5>Examples </h5>
<p>Suppose we have relation A.</p>
<pre class="code">
A = LOAD 'data' AS (f1:int, f2:int, B:bag{T:tuple(t1:int,t2:int)});

DUMP A;
(10,1,{(2,3),(4,6)})
(10,3,{(2,3),(4,6)})
(10,6,{(2,3),(4,6),(5,7)})
</pre>
<p>In this example the modulo operator is used with fields f1 and f2.</p>
<pre class="code">
X = FOREACH A GENERATE f1, f2, f1%f2;

DUMP X;
(10,1,0)
(10,3,1)
(10,6,4)
</pre>
<p>In this example the bincond operator is used with fields f2 and B. The condition is "f2 equals 1"; if the condition is true, return 1; if the condition is false, return the count of the number of tuples in B.</p>
<pre class="code">
X = FOREACH A GENERATE f2, (f2==1?1:COUNT(B));

DUMP X;
(1,1L)
(3,2L)
(6,3L)
</pre>
<a name="N10EC5"></a><a name="Types+Table%3A+addition+%28%2B%29+and+subtraction+%28-%29+operators"></a>
<h5> Types Table: addition (+) and subtraction (-) operators</h5>
<p>* bytearray cast as this data type</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p>map </p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>not yet </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>map </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>int </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as int </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>long </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as long &nbsp;</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>float </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as float &nbsp;</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>double </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as double &nbsp; </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>cast as double </p>
            
</td>
         
</tr>
   
</table>
<a name="N11123"></a><a name="Types+Table%3A+multiplication+%28*%29+and+division+%28%2F%29+operators"></a>
<h5>Types Table: multiplication (*) and division (/) operators</h5>
<p>* bytearray cast as this data type</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p>map </p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>not yet </p>
            
</td>
            <td>
               
<p>not yet </p>
            
</td>
            <td>
               
<p>not yet </p>
            
</td>
            <td>
               
<p>not yet </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>not yet </p>
            
</td>
            <td>
               
<p>not yet </p>
            
</td>
            <td>
               
<p>not yet </p>
            
</td>
            <td>
               
<p>not yet </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>map </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>int </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as int </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>long </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as long </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>float </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as float </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>double </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as double &nbsp;</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>cast as double &nbsp;</p>
            
</td>
         
</tr>
   
</table>
<a name="N11381"></a><a name="Types+Table%3A+modulo+%28%25%29+operator"></a>
<h5>Types Table: modulo (%) operator</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>int </p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>cast as int </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>long </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>cast as long </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
   
</table>
<a name="N113F3"></a><a name="Comparison+Operators"></a>
<h3 class="h4">Comparison Operators</h3>
<a name="N113F9"></a><a name="Description-N113F9"></a>
<h4>Description</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>Operator</p>
            
</td>
            <td>
               
<p>Symbol</p>
            
</td>
            <td>
               
<p>&nbsp;Notes</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>equal &nbsp;</p>
            
</td>
            <td>
               
<p>==</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>not equal </p>
            
</td>
            <td>
               
<p>!=</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>less than &nbsp;</p>
            
</td>
            <td>
               
<p>&lt;</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>greater than </p>
            
</td>
            <td>
               
<p>&gt;</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>less than or equal to &nbsp;</p>
            
</td>
            <td>
               
<p>&lt;=</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>greater than or equal to</p>
            
</td>
            <td>
               
<p>&gt;=</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>pattern matching &nbsp;</p>
            
</td>
            <td>
               
<p>matches</p>
            
</td>
            <td>
               
<p>Regular expression matching. &nbsp;Use the Java <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html">format</a> for regular expressions.</p>
            
</td>
         
</tr>
   
</table>
<p>Use the comparison operators with numeric and string data.</p>
<a name="N114AA"></a><a name="Example%3A+numeric"></a>
<h5>Example: numeric</h5>
<pre class="code">
X = FILTER A BY (f1 == 8);
</pre>
<a name="N114B4"></a><a name="Example%3A+string"></a>
<h5>Example: string</h5>
<pre class="code">
X = FILTER A BY (f2 == 'apache');
</pre>
<a name="N114BE"></a><a name="Example%3A+matches"></a>
<h5>Example: matches</h5>
<pre class="code">
X = FILTER A BY (f1 matches '.*apache.*');
</pre>
<a name="N114C8"></a><a name="Types+Table%3A+equal+%28%3D%3D%29+and+not+equal+%28%21%3D%29+operators"></a>
<h5>Types Table: equal (==) and not equal (!=) operators</h5>
<p>* bytearray cast as this data type</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p>map </p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean (see Note 1) </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>map </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
               
<p>(see Note 2)</p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>int </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as boolean </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>long </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as boolean </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>float </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as boolean &nbsp;</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>double </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as boolean &nbsp;</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>cast as boolean </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
         
</tr>
   
</table>
<p>Note 1: boolean (Tuple A is equal to tuple B if they have the same size s, and for all 0 &lt;= i &lt; s A[i] = = B[i])</p>
<p>Note 2: boolean (Map A is equal to map B if A and B have the same number of entries, and for every key k1 in A with a value of v1, there is a key k2 in B with a value of v2, such that k1 = = k2 and v1 = = v2)</p>
<a name="N1172F"></a>
<h5></h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p>map </p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>map </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>int </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>boolean (bytearray cast as int) </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>long </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>boolean (bytearray cast as long) </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>float </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>boolean (bytearray cast as float) </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>double </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>boolean (bytearray cast as double) </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean (bytearray cast as chararray) </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
         
</tr>
   
</table>
<a name="N11988"></a><a name="Types+Table%3A+matches+operator"></a>
<h5>Types Table: matches operator</h5>
<p>*Cast as chararray (the second argument must be chararray)</p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray* </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
            <td>
               
<p>boolean &nbsp;</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray </p>
            
</td>
            <td>
               
<p>boolean</p>
            
</td>
            <td>
               
<p>boolean </p>
            
</td>
         
</tr>
   
</table>
<a name="N119D2"></a><a name="Null+Operators"></a>
<h3 class="h4">Null Operators</h3>
<a name="N119D8"></a><a name="Description-N119D8"></a>
<h4>Description</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>Operator</p>
            
</td>
            <td>
               
<p>Symbol</p>
            
</td>
            <td>
               
<p>&nbsp;Notes</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>is null&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
            <td>
               
<p>is null</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>is not null &nbsp;</p>
            
</td>
            <td>
               
<p>is not null &nbsp;</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
   
</table>
<a name="N11A1E"></a><a name="Example-N11A1E"></a>
<h5>Example</h5>
<pre class="code">
X = FILTER A BY f1 is not null;
</pre>
<a name="N11A28"></a><a name="Types+Table"></a>
<h4>Types Table</h4>
<p>The null operators can be applied to all data types. For more information, see Nulls.</p>
<a name="N11A31"></a><a name="boolops"></a>
<h3 class="h4">Boolean Operators</h3>
<a name="N11A37"></a><a name="Description-N11A37"></a>
<h4>Description</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>Operator</p>
            
</td>
            <td>
               
<p>Symbol</p>
            
</td>
            <td>
               
<p>&nbsp;Notes</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>AND &nbsp; &nbsp; &nbsp; </p>
            
</td>
            <td>
               
<p>and</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>OR &nbsp;</p>
            
</td>
            <td>
               
<p>or</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>NOT</p>
            
</td>
            <td>
               
<p>not</p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
   
</table>
<p>Pig does not support a boolean data type. However, the result of a boolean expression (an expression that includes boolean and comparison operators) is always of type boolean (true or false).</p>
<a name="N11A94"></a><a name="Example-N11A94"></a>
<h5>Example</h5>
<pre class="code">
X = FILTER A BY (f1==8) OR (NOT (f2+f3 &gt; f1));
</pre>
<a name="N11A9E"></a><a name="deref"></a>
<h3 class="h4">Dereference Operators</h3>
<a name="N11AA4"></a><a name="Description-N11AA4"></a>
<h4>Description</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>Operator</p>
            
</td>
            <td>
               
<p>Symbol</p>
            
</td>
            <td>
               
<p>&nbsp;Notes</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple dereference &nbsp; &nbsp; &nbsp;</p>
            
</td>
            <td>
               
<p>tuple.id or tuple.(id,&hellip;)</p>
            
</td>
            <td>
               
<p>Tuple dereferencing can be done by name (tuple.field_name) or position (mytuple.$0). If a set of fields are dereferenced (tuple.(name1, name2) or tuple.($0, $1)), the expression represents a tuple composed of the specified fields. Note that if the dot operator is applied to a bytearray, the bytearray will be assumed to be a tuple.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bag dereference</p>
            
</td>
            <td>
               
<p>bag.id or bag.(id,&hellip;)</p>
            
</td>
            <td>
               
<p>Bag dereferencing can be done by name (bag.field_name) or position (bag.$0). If a set of fields are dereferenced (bag.(name1, name2) or bag.($0, $1)), the expression represents a bag composed of the specified fields.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>map dereference</p>
            
</td>
            <td>
               
<p>map#'key'</p>
            
</td>
            <td>
               
<p>Map dereferencing must be done by key (field_name#key or $0#key). If the pound operator is applied to a bytearray, the bytearray is assumed to be a map. If the key does not exist, the empty string is returned.</p>
            
</td>
         
</tr>
   
</table>
<a name="N11B01"></a><a name="Example%3A+Tuple"></a>
<h5>Example: Tuple</h5>
<p>Suppose we have relation A.</p>
<pre class="code">
LOAD 'data' as (f1:int, f2:tuple(t1:int,t2:int,t3:int));

DUMP A;
(1,(1,2,3))
(2,(4,5,6))
(3,(7,8,9))
(4,(1,4,7))
(5,(2,5,8))
</pre>
<p>In this example dereferencing is used to retrieve two fields from tuple f2.</p>
<pre class="code">
X = FOREACH A GENERATE f2.t1,f2.t3;

DUMP X;
(1,3)
(4,6)
(7,9)
(1,7)
(2,8)
</pre>
<a name="N11B14"></a><a name="Example%3A+Bag"></a>
<h5>Example: Bag</h5>
<p>Suppose we have relation B, formed by grouping relation A (see the GROUP operator for information about the field names in relation B).</p>
<pre class="code">
A = LOAD 'data' AS (f1:int, f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

ILLUSTRATE B;
<em>etc &hellip;</em>
----------------------------------------------------------
| b   | group: int | a: bag({f1: int,f2: int,f3: int}) |
----------------------------------------------------------
</pre>
<p>In this example dereferencing is used with relation X to project the first field (f1) of each tuple in the bag (a).</p>
<pre class="code">
X = FOREACH B GENERATE a.f1;

DUMP X;
({(1)})
({(4),(4)})
({(7)})
({(8),(8)})
</pre>
<a name="N11B2A"></a><a name="Example%3A+Tuple+and+Bag"></a>
<h5>Example: Tuple and Bag</h5>
<p>Suppose we have relation B, formed by grouping relation A &nbsp;(see the GROUP operator for information about the field names in relation B).</p>
<pre class="code">
A = LOAD 'data' AS (f1:int, f2:int, f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY (f1,f2);

DUMP B;
((1,2),{(1,2,3)})
((4,2),{(4,2,1)})
((4,3),{(4,3,3)})
((7,2),{(7,2,5)})
((8,3),{(8,3,4)})
((8,4),{(8,4,3)})

ILLUSTRATE B;
<em>etc &hellip;</em>
-------------------------------------------------------------------------------
| b     | group: tuple({f1: int,f2: int}) | a: bag({f1: int,f2: int,f3: int}) |
-------------------------------------------------------------------------------
|       | (8, 3)                                | {(8, 3, 4), (8, 3, 4)} |
-------------------------------------------------------------------------------
</pre>
<p>In this example dereferencing is used to project a field (f1) from a tuple (group) and a field (f1) from a bag (a).</p>
<pre class="code">
X = FOREACH B GENERATE group.f1, a.f1;

DUMP X;
(1,{(1)})
(4,{(4)})
(4,{(4)})
(7,{(7)})
(8,{(8)})
(8,{(8)})
</pre>
<a name="N11B40"></a><a name="Example%3A+Map"></a>
<h5>Example: Map</h5>
<p>Suppose we have relation A. </p>
<pre class="code">
A = LOAD 'data' AS (f1:int, f2:map[]);

DUMP A;
(1,[open#apache])
(2,[apache#hadoop])
(3,[hadoop#pig])
(4,[pig#grunt])
</pre>
<p>In this example dereferencing is used to look up the value of key 'open'.</p>
<pre class="code">
X = FOREACH A GENERATE f2#'open';

DUMP X;
(apache)
()
()
()
</pre>
<a name="N11B53"></a><a name="Sign+Operators"></a>
<h3 class="h4">Sign Operators</h3>
<a name="N11B59"></a><a name="Description-N11B59"></a>
<h4>Description</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>Operator</p>
            
</td>
            <td>
               
<p>Symbol</p>
            
</td>
            <td>
               
<p>&nbsp;Notes</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>positive &nbsp; &nbsp; &nbsp; </p>
            
</td>
            <td>
               
<p>+</p>
            
</td>
            <td>
               
<p>&nbsp;Has no effect.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>negative (negation)</p>
            
</td>
            <td>
               
<p>&nbsp;-</p>
            
</td>
            <td>
               
<p>&nbsp;Changes the sign of a positive or negative number.</p>
            
</td>
         
</tr>
   
</table>
<a name="N11BA1"></a><a name="Example-N11BA1"></a>
<h5>Example</h5>
<pre class="code">
A = LOAD 'data' as (x, y, z);

B = FOREACH A GENERATE -x, y;
</pre>
<a name="N11BAB"></a><a name="Types+Table%3A+negation+%28+-+%29+operator"></a>
<h5>Types Table: negation ( - ) operator</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>map </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>int </p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>long </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>float </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>double </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray </p>
            
</td>
            <td>
               
<p>double (as double) </p>
            
</td>
         
</tr>
   
</table>
<a name="N11C3B"></a><a name="Flatten+Operator"></a>
<h3 class="h4">Flatten Operator</h3>
<p>The FLATTEN operator looks like a UDF syntactically, but it is actually an operator that changes the structure of tuples 
   and bags in a way that a UDF cannot. Flatten un-nests tuples as well as bags. The idea is the same, but the operation and 
   result is different for each type of structure.</p>
<p>For tuples, flatten substitutes the fields of a tuple in place of the tuple. For example, consider a relation that has a tuple 
   of the form (a, (b, c)). The expression GENERATE $0, flatten($1), will cause that tuple to become (a, b, c).</p>
<p>For bags, the situation becomes more complicated. When we un-nest a bag, we create new tuples. If we have a 
   relation that is made up of tuples of the form ({(b,c),(d,e)}) and we apply GENERATE flatten($0), we end up with two 
   tuples (b,c) and (d,e). When we remove a level of nesting in a bag, sometimes we cause a cross product to happen. 
   For example, consider a relation that has a tuple of the form (a, {(b,c), (d,e)}), commonly produced by the GROUP operator. 
   If we apply the expression GENERATE $0, flatten($1) to this tuple, we will create new tuples: (a, b, c) and (a, d, e).</p>
<p>For examples using the FLATTEN operator, see <a href="#FOREACH">FOREACH</a>.</p>
<a name="N11C52"></a><a name="Cast+Operators"></a>
<h3 class="h4">Cast Operators</h3>
<a name="N11C58"></a><a name="Description-N11C58"></a>
<h4>Description</h4>
<p>Pig Latin supports casts as shown in this table. </p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>to </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>from </p>
            
</td>
            <td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p>map </p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bag </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>map </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>int </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>long </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>float </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error</p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p>yes </p>
            
</td>
            <td>
               
<p></p>
            
</td>
         
</tr>
   
</table>
<a name="N11F07"></a><a name="Syntax+%C2%A0"></a>
<h5>Syntax &nbsp;</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>{(data_type) | &nbsp;(tuple(data_type)) &nbsp;| (bag{tuple(data_type)}) | (map[]) } field</p>
            
</td>
         
</tr>
   
</table>
<a name="N11F19"></a><a name="Terms-N11F19"></a>
<h5>Terms</h5>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>(data_type)</p>
            
</td>
            <td>
               
<p>The data type you want to cast to, enclosed in parentheses. You can cast to any data type except bytearray (see the table above).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>field</p>
            
</td>
            <td>
               
<p>The field whose type you want to change. </p>
               
<p>The field can be represented by positional notation or by name (alias). For example, if f1 is the first field and type int, you can cast to type long using (long)$0 or (long)f1.</p>
            
</td>
         
</tr>
   
</table>
<a name="N11F43"></a><a name="Usage-N11F43"></a>
<h5>Usage</h5>
<p>Cast operators enable you to cast or convert data from one type to another, as long as conversion is supported (see the table above). For example, suppose you have an integer field, myint, which you want to convert to a string. You can cast this field from int to chararray using (chararray)myint.</p>
<p>Please note the following:</p>
<ul>
      
<li>
         
<p>A field can be explicitly cast. Once cast, the field remains that type (it is not automatically cast back). In this example $0 is explicitly cast to int.</p>
      
</li>
   
</ul>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>B = FOREACH A GENERATE (int)$0 + 1;</p>
            
</td>
         
</tr>
   
</table>
<p></p>
<ul>
      
<li>
         
<p>Where possible, Pig performs implicit casts. In this example $0 is cast to int (regardless of underlying data) and $1 is cast to double.</p>
      
</li>
   
</ul>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>B = FOREACH A GENERATE $0 + 1, $1 + 1.0</p>
            
</td>
         
</tr>
   
</table>
<ul>
      
<li>
         
<p>When two bytearrays are used in arithmetic expressions or with built-in aggregate functions (such as SUM) they are implicitly cast to double. If the underlying data is really int or long, you&rsquo;ll get better performance by declaring the type or explicitly casting the data.</p>
      
</li>
      
<li>
         
<p>Downcasts may cause loss of data. For example casting from long to int may drop bits.</p>
      
</li>
   
</ul>
<a name="N11F8A"></a><a name="Examples-N11F8A"></a>
<h5>Examples</h5>
<p>In this example an int is cast to type chararray (see relation X).</p>
<pre class="code">
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

DESCRIBE B;
B: {group: int,A: {f1: int,f2: int,f3: int}}

X = FOREACH B GENERATE group, (chararray)COUNT(A) AS total;
(1,1)
(4,2)
(7,1)
(8,2)

DESCRIBE X;
X: {group: int,total: chararray}
</pre>
<p>In this example a bytearray (fld in relation A) is cast to type tuple.</p>
<pre class="code">
cat data;
(1,2,3)
(4,2,1)
(8,3,4)

A = LOAD 'data' AS fld:bytearray;

DESCRIBE A;
a: {fld: bytearray}

DUMP A;
((1,2,3))
((4,2,1))
((8,3,4))

B = FOREACH A GENERATE (tuple(int,int,float))fld;

DESCRIBE B;
b: {(int,int,float)}

DUMP B;
((1,2,3))
((4,2,1))
((8,3,4))
</pre>
<p>In this example a bytearray (fld in relation A) is cast to type bag.</p>
<pre class="code">
cat data;
{(4829090493980522200L)}
{(4893298569862837493L)}
{(1297789302897398783L)}

A = LOAD 'data' AS fld:bytearray;

DESCRIBE A;
A: {fld: bytearray}

DUMP A;
({(4829090493980522200L)})
({(4893298569862837493L)})
({(1297789302897398783L)})

B = FOREACH A GENERATE (bag{tuple(long)})fld; 

DESCRIBE B;
B: {{(long)}}

DUMP B;
({(4829090493980522200L)})
({(4893298569862837493L)})
({(1297789302897398783L)})
</pre>
<p>In this example a bytearray (fld in relation A) is cast to type map.</p>
<pre class="code">
cat data;
[open#apache]
[apache#hadoop]
[hadoop#pig]
[pig#grunt]

A = LOAD 'data' AS fld:bytearray;

DESCRIBE A;
A: {fld: bytearray}

DUMP A;
([open#apache])
([apache#hadoop])
([hadoop#pig])
([pig#grunt])

B = FOREACH A GENERATE ((map[])fld;

DESCRIBE B;
B: {map[ ]}

DUMP B;
([open#apache])
([apache#hadoop])
([hadoop#pig])
([pig#grunt])
</pre>
</div>

<!-- RELATIONAL OPERATORS, ETC -->
   
   
<a name="N11FAC"></a><a name="Relational+Operators"></a>
<h2 class="h3">Relational Operators</h2>
<div class="section">
<a name="N11FB2"></a><a name="COGROUP"></a>
<h3 class="h4">COGROUP</h3>
<p>COGROUP is the same as GROUP. For readability, programmers usually use GROUP when only one relation is involved and COGROUP with multiple relations re involved. See <a href="#GROUP">GROUP</a> for more information.</p>
<a name="N11FC0"></a><a name="CROSS"></a>
<h3 class="h4">CROSS</h3>
<p>Computes the cross product of two or more relations.</p>
<a name="N11FC9"></a><a name="Syntax-N11FC9"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias = CROSS alias, alias [, alias &hellip;] [PARALLEL n];</p>
            
</td>
         
</tr>
   
</table>
<a name="N11FDB"></a><a name="Terms-N11FDB"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation. </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>PARALLEL n</p>
            
</td>
            <td>
               
<p>Increase the parallelism of a job by specifying the number of reduce tasks, n. The default value for n is 1 (one reduce task). Note the following:</p>
               
<ul>
                  
<li>
                     
<p>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </p>
                  
</li>
                  
<li>
                     
<p>If you don&rsquo;t specify parallel, you still get the same map parallelism but only one reduce task. </p>
                  
</li>
               
</ul>
               
<p>For more information, see the <a href="cookbook.html#Use+the+PARALLEL+Clause">Pig Cookbook</a>.</p>
            
</td>
         
</tr>
   
</table>
<a name="N12018"></a><a name="Usage-N12018"></a>
<h4>Usage</h4>
<p>Use the CROSS operator to compute the cross product (Cartesian product) of two or more relations.</p>
<p>CROSS is an expensive operation and should be used sparingly. </p>
<a name="N12024"></a><a name="Example-N12024"></a>
<h4>Example</h4>
<p>Suppose we have relations A and B.</p>
<pre class="code">
A = LOAD 'data1' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)

B = LOAD 'data2' AS (b1:int,b2:int);

DUMP B;
(2,4)
(8,9)
(1,3)
</pre>
<p>In this example the cross product of relation A and B is computed.</p>
<pre class="code">
X = CROSS A, B;

DUMP X;
(1,2,3,2,4)
(1,2,3,8,9)
(1,2,3,1,3)
(4,2,1,2,4)
(4,2,1,8,9)
(4,2,1,1,3)
</pre>
<a name="N12037"></a><a name="DISTINCT"></a>
<h3 class="h4">DISTINCT </h3>
<p>Removes duplicate tuples in a relation.</p>
<a name="N12040"></a><a name="Syntax-N12040"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias = DISTINCT alias [PARALLEL n];&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N12052"></a><a name="Terms-N12052"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of the relation.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>PARALLEL n</p>
            
</td>
            <td>
               
<p>Increase the parallelism of a job by specifying the number of reduce tasks, n. The default value for n is 1 (one reduce task). Note the following:</p>
               
<ul>
                  
<li>
                     
<p>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </p>
                  
</li>
                  
<li>
                     
<p>If you don&rsquo;t specify parallel, you still get the same map parallelism but only one reduce task. </p>
                  
</li>
               
</ul>
               
<p>For more information, see the <a href="cookbook.html#Use+the+PARALLEL+Clause">Pig Cookbook</a>.</p>
            
</td>
         
</tr>
   
</table>
<a name="N1208F"></a><a name="Usage-N1208F"></a>
<h4>Usage</h4>
<p>Use the DISTINCT operator to remove duplicate tuples in a relation. DISTINCT does not preserve the original order of the contents (to eliminate duplicates, Pig must first sort the data). You cannot use DISTINCT on a subset of fields. To do this, use FOREACH &hellip; GENERATE to select the fields, and then use DISTINCT.</p>
<a name="N12098"></a><a name="Example-N12098"></a>
<h4>Example</h4>
<p>Suppose we have relation A.</p>
<pre class="code">
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(8,3,4)
(1,2,3)        
(4,3,3)        
(4,3,3)        
(1,2,3) 
</pre>
<p>In this example all duplicate tuples are removed.</p>
<pre class="code">
X = DISTINCT A;

DUMP X;
(1,2,3)
(4,3,3)
(8,3,4)
</pre>
<a name="N120AB"></a><a name="FILTER"></a>
<h3 class="h4">FILTER </h3>
<p>Selects tuples from a relation based on some condition.</p>
<a name="N120B4"></a><a name="Syntax-N120B4"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias = FILTER alias &nbsp;BY expression;</p>
            
</td>
         
</tr>
   
</table>
<a name="N120C6"></a><a name="Terms-N120C6"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of the relation.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>BY</p>
            
</td>
            <td>
               
<p>Required keyword.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>A boolean expression.</p>
            
</td>
         
</tr>
   
</table>
<a name="N120FC"></a><a name="Usage-N120FC"></a>
<h4>Usage</h4>
<p>Use the FILTER operator to work with tuples or rows of data (if you want to work with columns of data, use the FOREACH &hellip;GENERATE operation).</p>
<p>FILTER is commonly used to select the data that you want; or, conversely, to filter out (remove) the data you don&rsquo;t want.</p>
<a name="N12108"></a><a name="Examples-N12108"></a>
<h4>Examples</h4>
<p>Suppose we have relation A.</p>
<pre class="code">
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</pre>
<p>In this example the condition states that if the third field equals 3, then include the tuple with relation X.</p>
<pre class="code">
X = FILTER A BY f3 == 3;

DUMP X;
(1,2,3)
(4,3,3)
(8,4,3)
</pre>
<p>In this example the condition states that if the first field equals 8 or if the sum of fields f2 and f3 is not greater than first field, then include the tuple relation X.</p>
<pre class="code">
X = FILTER A BY (f1 == 8) OR (NOT (f2+f3 &gt; f1));

DUMP X;
(4,2,1)
(8,3,4)
(7,2,5)
(8,4,3)
</pre>
<a name="N12121"></a><a name="FOREACH"></a>
<h3 class="h4">FOREACH</h3>
<p>Generates data transformations based on columns of data.</p>
<a name="N1212A"></a><a name="Syntax-N1212A"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias &nbsp;= FOREACH { gen_blk | nested_gen_blk } [AS schema];</p>
            
</td>
         
</tr>
   
</table>
<a name="N1213C"></a><a name="Terms-N1213C"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias </p>
            
</td>
            <td>
               
<p>The name of relation (outer bag).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>gen_blk</p>
            
</td>
            <td>
               
<p>FOREACH &hellip; GENERATE used with a relation (outer bag). Use this syntax:</p>
               
<p></p>
               
<p>alias = FOREACH alias GENERATE expression [expression &hellip;.]</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>nested_gen_blk</p>
            
</td>
            <td>
               
<p>FOREACH &hellip; GENERATE used with a inner bag. Use this syntax:</p>
               
<p></p>
               
<p>alias = FOREACH nested_alias {</p>
               
<p>&nbsp; &nbsp;alias = nested_op; [alias = nested_op; &hellip;]</p>
               
<p>&nbsp; &nbsp;GENERATE expression [, expression &hellip;]</p>
               
<p>};</p>
               
<p></p>
               
<p>Where:</p>
               
<p>The nested block is enclosed in opening and closing brackets { &hellip; }. </p>
               
<p>The GENERATE keyword must be the last statement within the nested block.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>nested_alias</p>
            
</td>
            <td>
               
<p>The name of the inner bag.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>nested_op</p>
            
</td>
            <td>
               
<p>Allowed operations are DISTINCT, FILTER, LIMIT, ORDER and SAMPLE. </p>
               
<p>The FOREACH &hellip; GENERATE operation itself is not allowed since this could lead to an arbitrary number of nesting levels.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>AS</p>
            
</td>
            <td>
               
<p>Keyword.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>schema</p>
            
</td>
            <td>
               
<p>A schema using the AS keyword (see Schemas).</p>
               
<ul>
                  
<li>
                     
<p>If the <a href="#Flatten+Operator">FLATTEN</a> operator is used, enclose the schema in parentheses.</p>
                  
</li>
                  
<li>
                     
<p>If the FLATTEN operator is not used, don't enclose the schema in parentheses.</p>
                  
</li>
               
</ul>
            
</td>
         
</tr>
   
</table>
<a name="N121F1"></a><a name="Usage-N121F1"></a>
<h4>Usage</h4>
<p>Use the FOREACH &hellip;GENERATE operation to work with columns of data (if you want to work with tuples or rows of data, use the FILTER operation).</p>
<p>FOREACH &hellip;GENERATE works with relations (outer bags) as well as inner bags:</p>
<ul>
      
<li>
         
<p>If A is a relation (outer bag), a FOREACH statement could look like this.</p>

<pre class="code">
X = FOREACH A GENERATE f1;
</pre>
      
</li>
      
<li>
         
<p>If A is an inner bag, a FOREACH statement could look like this.</p>
  
<pre class="code">
X = FOREACH B {
        S = FILTER A BY 'xyz';
        GENERATE COUNT (S.$0);
}
</pre>
      
</li>
   
</ul>
<a name="N12213"></a><a name="Examples-N12213"></a>
<h4>Examples</h4>
<p>Suppose we have relations A, B, and C (see the GROUP operator for information about the field names in relation C).</p>
<pre class="code">
A = LOAD 'data1' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = LOAD 'data2' AS (b1:int,b2:int);

DUMP B;
(2,4)
(8,9)
(1,3)
(2,7)
(2,9)
(4,6)
(4,9)

C = COGROUP A BY a1 inner, B BY b1 inner;

DUMP C;
(1,{(1,2,3)},{(1,3)})
(4,{(4,2,1),(4,3,3)},{(4,6),(4,9)})
(8,{(8,3,4),(8,4,3)},{(8,9)})

ILLUSTRATE C;
<em>etc &hellip;</em>
--------------------------------------------------------------------------------------
| c     | group: int | a: bag({a1: int,a2: int,a3: int}) | B: bag({b1: int,b2: int}) |
--------------------------------------------------------------------------------------
|       | 1          | {(1, 2, 3)}                       | {(1, 3)}                  |
-------------------------------------------------------------------------------------
</pre>
<a name="N12223"></a><a name="Example%3A+Projection"></a>
<h4>Example: Projection</h4>
<p>In this example the asterisk (*) is used to project all tuples from relation A to relation X. Relation A and X are identical.</p>
<pre class="code">
X = FOREACH A GENERATE *;

DUMP X;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</pre>
<p>In this example two fields from relation A are projected to form relation X. </p>
<pre class="code">
X = FOREACH A GENERATE a1, a2;

DUMP X;
(1,2)
(4,2)
(8,3)
(4,3)
(7,2)
(8,4)
</pre>
<a name="N12236"></a><a name="Example%3A+Nested+Projection"></a>
<h4>Example: Nested Projection</h4>
<p>In this example if one of the fields in the input relation is a tuple, bag or map, we can perform a projection on that field (using a deference operator).</p>
<pre class="code">
X = FOREACH C GENERATE group, B.b2;

DUMP X;
(1,{(3)})
(4,{(6),(9)})
(8,{(9)})
</pre>
<p>In this example multiple nested columns are retained.</p>
<pre class="code">
X = FOREACH C GENERATE group, A.(a1, a2);

DUMP X;
(1,{(1,2)})
(4,{(4,2),(4,3)})
(8,{(8,3),(8,4)})
</pre>
<a name="N12249"></a><a name="Example%3A+Schema"></a>
<h4>Example: Schema</h4>
<p>In this example two fields in relation A are summed to form relation X. A schema is defined for the projected field.</p>
<pre class="code">
X = FOREACH A GENERATE a1+a2 AS f1:int;

DESCRIBE X;
x: {f1: int}

DUMP X;
(3)
(6)
(11)
(7)
(9)
(12)

Y = FILTER X BY f1 &gt; 10;

DUMP Y;
(11)
(12)
</pre>
<a name="N12256"></a><a name="Example%3A+Applying+Functions"></a>
<h4>Example: Applying Functions</h4>
<p>In this example the built-in function SUM() is used to sum a set of numbers in a bag.</p>
<pre class="code">
X = FOREACH C GENERATE group, SUM (A.a1);

DUMP X;
(1,1)
(4,8)
(8,16)
</pre>
<a name="N12263"></a><a name="Example%3A+Flattening"></a>
<h4>Example: Flattening</h4>
<p>In this example the <a href="#Flatten+Operator">FLATTEN</a> operator is used to eliminate nesting. </p>
<pre class="code">
X = FOREACH C GENERATE group, FLATTEN(A);

DUMP X;
(1,1,2,3)
(4,4,2,1)
(4,4,3,3)
(8,8,3,4)
(8,8,4,3)
</pre>
<p>Another FLATTEN example.</p>
<pre class="code">
X = FOREACH C GENERATE GROUP, FLATTEN(A.a3);

DUMP X;
(1,3)
(4,1)
(4,3)
(8,4)
(8,3)
</pre>
<p>Another FLATTEN example. Note that for the group '4' in C, there are two tuples in each bag. Thus, when both bags are flattened, the cross product of these tuples is returned; that is, tuples (4, 2, 6), (4, 3, 6), (4, 2, 9), and (4, 3, 9).</p>
<pre class="code">
X = FOREACH C GENERATE FLATTEN(A.(a1, a2)), FLATTEN(B.$1);

DUMP X;
(1,2,3)
(4,2,6)
(4,2,9)
(4,3,6)
(4,3,9)
(8,3,9)
(8,4,9)
</pre>
<p>Another FLATTEN example. Here, relations A and B both have a column x. When forming relation E,  you need to use the :: operator to identify which column x to use - either relation A column x (A::x) or relation B column x (B::x). This example uses relation A column x (A::x).</p>
<pre class="code">
A = load 'data' as (x, y);
B = load 'data' as (x, z);
C = cogroup A by x, B by x;
D = foreach C generate flatten(A), flatten(b);
E = group D by A::x;
&hellip;&hellip;
</pre>
<a name="N12286"></a><a name="Example%3A+Nested+Block"></a>
<h4>Example: Nested Block</h4>
<p>Suppose we have relations A and B. Note that relation B contains an inner bag.</p>
<pre class="code">
A = LOAD 'data' AS (url:chararray,outline:chararray);

DUMP A;
(www.ccc.com,www.hjk.com)
(www.ddd.com,www.xyz.org)
(www.aaa.com,www.cvn.org)
(www.www.com,www.kpt.net)
(www.www.com,www.xyz.org)
(www.ddd.com,www.xyz.org)

B = GROUP A BY url;

DUMP B;
(www.aaa.com,{(www.aaa.com,www.cvn.org)})
(www.ccc.com,{(www.ccc.com,www.hjk.com)})
(www.ddd.com,{(www.ddd.com,www.xyz.org),(www.ddd.com,www.xyz.org)})
(www.www.com,{(www.www.com,www.kpt.net),(www.www.com,www.xyz.org)})
</pre>
<p>In this example we perform two of the operations allowed in a nested block, FILTER and DISTINCT. Note that the last statement in the nested block must be GENERATE.</p>
<pre class="code">
X = foreach B {
        FA= FILTER A BY outlink == 'www.xyz.org';
        PA = FA.outlink;
        DA = DISTINCT PA;
        GENERATE GROUP, COUNT(DA);
}

DUMP X;
(www.ddd.com,1L)
(www.www.com,1L)
</pre>
<a name="N12299"></a><a name="GROUP"></a>
<h3 class="h4">GROUP</h3>
<p>Groups the data in one or multiple relations. GROUP is the same as <a href="#COGROUP">COGROUP</a>. For
readability, programmers usually use GROUP when only one relation is involved and COGROUP with multiple relations are involved. </p>
<a name="N122A6"></a><a name="Syntax-N122A6"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias = GROUP alias { ALL | BY expression}&nbsp;[, alias ALL | BY expression &hellip;]  [USING 'collected'] [PARALLEL n];</p>
            
</td>
         
</tr>
   
</table>
<a name="N122B8"></a><a name="Terms-N122B8"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias </p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
                  
<tr>
            
<td>
               
<p>ALL</p>
            
</td>
            <td>
               
<p>Keyword. Use ALL if you want all tuples to go to a single group; for example, when doing aggregates across entire relations.</p>
               
<p>B = GROUP A ALL;</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>BY</p>
            
</td>
            <td>
               
<p>Keyword. Use this clause to group the relation by field, tuple or expression.</p>
               
<p>B = GROUP A BY f1;</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>A tuple expression. This is the group key or key field. If the result of the tuple expression is a single field, the key will be the value of the first field rather than a tuple with one field. To group using multiple keys, enclose the keys in parentheses:</p>
               
<p>B = GROUP A BY (key1,key2);</p>
            
</td>
         
</tr>
         
         
<tr>
            
<td>
               
<p>USING</p>
            
</td>
            <td>
               
<p>Keyword</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>'collected'</p>
            
</td>
            <td>
               
<p>Allows for more efficient computation of a group if the loader guarantees that the data for the 
               same key is continuous and is given to a single map. As of this release, only the Zebra loader makes this 
               guarantee. The efficiency is achieved by performing the group operation in map
               rather than reduce (see <a href="zebra_pig.html">Zebra and Pig</a>). This feature cannot be used with the COGROUP operator.</p>
            
</td>
         
</tr>         
         

         
<tr>
            
<td>
               
<p>PARALLEL n</p>
            
</td>
            <td>
               
<p>Increase the parallelism of a job by specifying the number of reduce tasks, n. The default value for n is 1 (one reduce task). Note the following:</p>
               
<ul>
                  
<li>
                     
<p>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </p>
                  
</li>
                  
<li>
                     
<p>If you don&rsquo;t specify parallel, you still get the same map parallelism but only one reduce task. </p>
                  
</li>
               
</ul>
               
<p>For more information, see the <a href="cookbook.html#Use+the+PARALLEL+Clause">Pig Cookbook</a>.</p>
            
</td>
         
</tr>
   
</table>
<a name="N1234D"></a><a name="Usage-N1234D"></a>
<h4>Usage</h4>
<p>The GROUP operator groups together tuples that have the same group key (key field). The key field will be a tuple if the group key has more than one field, otherwise it will be the same type as that of the group key. The result of a GROUP operation is a relation that includes one tuple per group. This tuple contains two fields: </p>
<ul>
      
<li>
         
<p>The first field is named "group" (do not confuse this with the GROUP operator) and is the same type as the group key.</p>
      
</li>
      
<li>
         
<p>The second field takes the name of the original relation and is type bag.</p>
     
</li>
     
<li>
         
<p>The names of both fields are generated by the system as shown in the example below.</p>
      
</li>
   
</ul>
<p></p>
<p>
   Note that the GROUP (and thus COGROUP) and JOIN operators perform similar functions. GROUP creates a nested set of output tuples while JOIN creates a flat set of output tuples.
   </p>
<a name="N12371"></a><a name="Example-N12371"></a>
<h4>Example</h4>
<p>Suppose we have relation A.</p>
<pre class="code">
A = load 'student' AS (name:chararray,age:int,gpa:float);

DESCRIBE A;
A: {name: chararray,age: int,gpa: float}

DUMP A;
(John,18,4.0F)
(Mary,19,3.8F)
(Bill,20,3.9F)
(Joe,18,3.8F)
</pre>
<p>Now, suppose we group relation A on field "age" for form relation B. We can use the DESCRIBE and ILLUSTRATE operators to examine the structure of relation B. Relation B has two fields. The first field is named "group" and is type int, the same as field "age" in relation A. The second field is name "A" &nbsp;after relation A and is type bag.</p>
<pre class="code">
B = GROUP A BY age;

DESCRIBE B;
B: {group: int, A: {name: chararray,age: int,gpa: float}}

ILLUSTRATE B;
<em>etc &hellip;</em>
----------------------------------------------------------------------
| B     | group: int | A: bag({name: chararray,age: int,gpa: float}) |
----------------------------------------------------------------------
|       | 18         | {(John, 18, 4.0), (Joe, 18, 3.8)}             |
|       | 20         | {(Bill, 20, 3.9)}                             |
----------------------------------------------------------------------

DUMP B;
(18,{(John,18,4.0F),(Joe,18,3.8F)})
(19,{(Mary,19,3.8F)})
(20,{(Bill,20,3.9F)})
</pre>
<p>Continuing on, as shown in these FOREACH statements, we can refer to the fields in relation B by names "group" and "A" or by positional notation.</p>
<pre class="code">
C = FOREACH B GENERATE group, COUNT(A);

DUMP C;
(18,2L)
(19,1L)
(20,1L)

C = FOREACH B GENERATE $0, $1.name;

DUMP C;
(18,{(John),(Joe)})
(19,{(Mary)})
(20,{(Bill)})
</pre>
<a name="N1238D"></a><a name="Example-N1238D"></a>
<h4>Example</h4>
<p>Suppose we have relation A.</p>
<pre class="code">
A = LOAD 'data' as (f1:chararray, f2:int, f3:int);

DUMP A;
(r1,1,2)
(r2,2,1)
(r3,2,8)
(r4,4,4)
</pre>
<p>In this example the tuples are grouped using an expression, f2*f3.</p>
<pre class="code">
X = GROUP A BY f2*f3;

DUMP X;
(2,{(r1,1,2),(r2,2,1)})
(16,{(r3,2,8),(r4,4,4)})
</pre>
<p>Suppose we have two relations, A and B.</p>
<pre class="code">
A = LOAD 'data1' AS (owner:chararray,pet:chararray);

DUMP A;
(Alice,turtle)
(Alice,goldfish)
(Alice,cat)
(Bob,dog)
(Bob,cat)

B = LOAD 'data2' AS (friend1:chararray,friend2:chararray);

DUMP B;
(Cindy,Alice)
(Mark,Alice)
(Paul,Bob)
(Paul,Jane)
</pre>
<p>In this example tuples are co-grouped using field &ldquo;owner&rdquo; from relation A and field &ldquo;friend2&rdquo; from relation B as the key fields. The DESCRIBE operator shows the schema for relation X, which has two fields, "group" and "A" (see the GROUP operator for information about the field names).</p>
<pre class="code">
X = COGROUP A BY owner, B BY friend2;

DESCRIBE X;
X: {group: chararray,A: {owner: chararray,pet: chararray},b: {firend1: chararray,friend2: chararray}}
</pre>
<p>Relation X looks like this. A tuple is created for each unique key field. The tuple includes the key field and two bags. The first bag is the tuples from the first relation with the matching key field. The second bag is the tuples from the second relation with the matching key field. If no tuples match the key field, the bag is empty.</p>
<pre class="code">
(Alice,{(Alice,turtle),(Alice,goldfish),(Alice,cat)},{(Cindy,Alice),(Mark,Alice)})
(Bob,{(Bob,dog),(Bob,cat)},{(Paul,Bob)})
(Jane,{},{(Paul,Jane)})
</pre>
<p>In this example tuples are co-grouped and the INNER keyword is used to ensure that only bags with at least one tuple are returned. </p>
<pre class="code">
X = COGROUP A BY owner INNER, B BY friend2 INNER;

DUMP X;
(Alice,{(Alice,turtle),(Alice,goldfish),(Alice,cat)},{(Cindy,Alice),(Mark,Alice)})
(Bob,{(Bob,dog),(Bob,cat)},{(Paul,Bob)})
</pre>
<p>In this example tuples are co-grouped and the INNER keyword is used asymmetrically on only one of the relations.</p>
<pre class="code">
X = COGROUP A BY owner, B BY friend2 INNER;

DUMP X;
(Bob,{(Bob,dog),(Bob,cat)},{(Paul,Bob)})
(Jane,{},{(Paul,Jane)})
(Alice,{(Alice,turtle),(Alice,goldfish),(Alice,cat)},{(Cindy,Alice),(Mark,Alice)})
</pre>
<a name="N123BE"></a><a name="Example-N123BE"></a>
<h4>Example</h4>
<p>This example shows to group using multiple keys.</p>
<pre class="code">
 A = LOAD 'allresults' USING PigStorage() AS (tcid:int, tpid:int, date:chararray, result:chararray, tsid:int, tag:chararray);
 B = GROUP A BY (tcid, tpid); 
</pre>
<a name="N123CB"></a><a name="Example-N123CB"></a>
<h4>Example</h4>
<p>This example shows a map-side group.</p>
<pre class="code">
 register zebra.jar;
 A = LOAD 'studentsortedtab' USING org.apache.hadoop.zebra.pig.TableLoader('name, age, gpa&rsquo;, 'sorted');
 B = GROUP A BY name USING "collected";
 C = FOREACH b GENERATE group, MAX(a.age), COUNT_STAR(a);
</pre>
<a name="N123D9"></a><a name="JOIN+%28inner%29"></a>
<h3 class="h4">JOIN (inner) </h3>
<p>Performs inner, equijoin of two or more relations based on common field values.</p>
<a name="N123E2"></a><a name="Syntax-N123E2"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias = JOIN alias BY {expression|'('expression [, expression &hellip;]')'} (, alias BY {expression|'('expression [, expression &hellip;]')'} &hellip;) [USING 'replicated' | 'skewed' | 'merge'] [PARALLEL n];&nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N123F4"></a><a name="Terms-N123F4"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>BY</p>
            
</td>
            <td>
               
<p>Keyword</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>A field expression.</p>
               
<p>Example: X = JOIN A BY fieldA, B BY fieldB, C BY fieldC;</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>USING</p>
            
</td>
            <td>
               
<p>Keyword</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>'replicated'</p>
            
</td>
            <td>
               
<p>Use to perform replicated joins (see <a href="piglatin_ref1.html#Replicated+Joins">Replicated Joins</a>).</p>
            
</td>
         
</tr>
         
                  
<tr>
            
<td>
               
<p>'skewed'</p>
            
</td>
            <td>
               
<p>Use to perform skewed joins (see <a href="piglatin_ref1.html#Skewed+Joins">Skewed Joins</a>).</p>
            
</td>
         
</tr>
         
                  
<tr>
            
<td>
               
<p>'merge'</p>
            
</td>
            <td>
               
<p>Use to perform merge joins (see <a href="piglatin_ref1.html#Merge+Joins">Merge Joins</a>).</p>
            
</td>
         
</tr>
         
         
         
<tr>
            
<td>
               
<p>PARALLEL n</p>
            
</td>
            <td>
               
<p>Increase the parallelism of a job by specifying the number of reduce tasks, n. The default value for n is 1 (one reduce task). Note the following:</p>
               
<ul>
                  
<li>
                     
<p>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </p>
                  
</li>
                  
<li>
                     
<p>If you don&rsquo;t specify parallel, you still get the same map parallelism but only one reduce task. </p>
                  
</li>
               
</ul>
               
<p>For more information, see the <a href="cookbook.html#Use+the+PARALLEL+Clause">Pig Cookbook</a>.</p>
            
</td>
         
</tr>
   
</table>
<a name="N1249A"></a><a name="Usage-N1249A"></a>
<h4>Usage</h4>
<p>Use the JOIN operator to perform an inner, equijoin join of two or more relations based on common field values. 
   The JOIN operator always performs an inner join. Inner joins ignore null keys, so it makes sense to filter them out before the join.</p>
<p>Note that the JOIN and COGROUP operators perform similar functions. 
   JOIN creates a flat set of output records while COGROUP creates a nested set of output records.</p>
<a name="N124A7"></a><a name="Example-N124A7"></a>
<h4>Example</h4>
<p>Suppose we have relations A and B.</p>
<pre class="code">
A = LOAD 'data1' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = LOAD 'data2' AS (b1:int,b2:int);

DUMP B;
(2,4)
(8,9)
(1,3)
(2,7)
(2,9)
(4,6)
(4,9)
</pre>
<p>In this example relations A and B are joined by their first fields.</p>
<pre class="code">
X = JOIN A BY a1, B BY b1;

DUMP X;
(1,2,3,1,3)
(4,2,1,4,6)
(4,3,3,4,6)
(4,2,1,4,9)
(4,3,3,4,9)
(8,3,4,8,9)
(8,4,3,8,9)
</pre>
<a name="N124BB"></a><a name="JOIN+%28outer%29"></a>
<h3 class="h4">JOIN (outer) </h3>
<p>Performs an outer join of two or more relations based on common field values.</p>
<a name="N124C4"></a><a name="Syntax-N124C4"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias = JOIN left-alias BY left-alias-column [LEFT|RIGHT|FULL] [OUTER], right-alias BY right-alias-column 
               [USING 'replicated' | 'skewed'] [PARALLEL n];&nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N124D7"></a><a name="Terms-N124D7"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
   
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation. Applies to alias, left-alias and right-alias.</p>
            
</td>
        
</tr>
        
<tr>
            
<td>
               
<p>alias-column</p>
            
</td>
            <td>
               
<p>The name of the join column for the corresponding relation. Applies to left-alias-column and right-alias-column.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>BY</p>
            
</td>
            <td>
               
<p>Keyword</p>
            
</td>
         
</tr>

         
<tr>
            
<td>
               
<p>LEFT</p>
            
</td>
            <td>
               
<p>Left outer join.</p>
            
</td>
         
</tr>
         
         
<tr>
            
<td>
               
<p>RIGHT</p>
            
</td>
            <td>
               
<p>Right outer join.</p>
            
</td>
         
</tr>
         
              
<tr>
            
<td>
               
<p>FULL</p>
            
</td>
            <td>
               
<p>Full outer join.</p>
            
</td>
         
</tr>

         
<tr>
            
<td>
               
<p>OUTER</p>
            
</td>
            <td>
               
<p>(Optional) Keyword </p>
            
</td>
         
</tr>

  
<tr>
            
<td>
               
<p>USING</p>
            
</td>
            <td>
               
<p>Keyword</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>'replicated'</p>
            
</td>
            <td>
               
<p>Use to perform replicated joins (see <a href="piglatin_ref1.html#Replicated+Joins">Replicated Joins</a>).</p>
               
<p>Only left outer join is supported for replicated joins.</p>
            
</td>
         
</tr>
         
                  
<tr>
            
<td>
               
<p>'skewed'</p>
            
</td>
            <td>
               
<p>Use to perform skewed joins (see <a href="piglatin_ref1.html#Skewed+Joins">Skewed Joins</a>).</p>
            
</td>
         
</tr>


         
<tr>
            
<td>
               
<p>PARALLEL n</p>
            
</td>
            <td>
               
<p>Increase the parallelism of a job by specifying the number of reduce tasks, n. The default value for n is 1 (one reduce task). Note the following:</p>
               
<ul>
                  
<li>
                     
<p>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </p>
                  
</li>
                  
<li>
                     
<p>If you don&rsquo;t specify parallel, you still get the same map parallelism but only one reduce task. </p>
                  
</li>
               
</ul>
               
<p>For more information, see the <a href="cookbook.html#Use+the+PARALLEL+Clause">Pig Cookbook</a>.</p>
            
</td>
         
</tr>
   
   
</table>
<a name="N125A7"></a><a name="Usage-N125A7"></a>
<h4>Usage</h4>
<p>Use the OUTER JOIN operator to perform left, right, or full outer joins. The Pig Latin syntax closely adheres to the SQL standard. 
   The keyword OUTER is optional for outer joins (the keywords LEFT, RIGHT and FULL will imply left outer, right outer and full outer joins respectively
    when OUTER is omitted). </p>
<p>
   Please note the following:
    </p>
<ul>
		
<li>
			
<p>Outer joins will only work provided the relations which need to produce nulls (in the case of non-matching keys) have schemas.</p>
		
</li>
		
<li>
			
<p>Outer joins will only work for two-way joins; to perform a multi-way outer join, you will need to perform multiple two-way outer join statements.</p>
		
</li>
    
</ul>
<a name="N125C3"></a><a name="Examples-N125C3"></a>
<h4>Examples</h4>
<p>This example shows a left outer join.</p>
<pre class="code">
A = LOAD 'a.txt' AS (n:chararray, a:int); 
B = LOAD 'b.txt' AS (n:chararray, m:chararray);
C = JOIN A by $0 LEFT OUTER, B BY $0;
</pre>
<p>This example shows a full outer join.</p>
<pre class="code">
A = LOAD 'a.txt' AS (n:chararray, a:int); 
B = LOAD 'b.txt' AS (n:chararray, m:chararray);
C = JOIN A BY $0 FULL, B BY $0;
</pre>
<p>This example shows a replicated left outer join.</p>
<pre class="code">
A = LOAD 'large';
B = LOAD 'tiny';
C= JOIN A BY $0 LEFT, B BY $0 USING 'replicated';
</pre>
<p>This example shows a skewed full outer join.</p>
<pre class="code">
A = LOAD 'studenttab' as (name, age, gpa);
B = LOAD 'votertab' as (name, age, registration, contribution);
C = JOIN A BY name FULL, B BY name USING 'skewed';
</pre>
<a name="N125E3"></a><a name="LIMIT"></a>
<h3 class="h4">LIMIT </h3>
<p>Limits the number of output tuples.</p>
<a name="N125EC"></a><a name="Syntax-N125EC"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias = LIMIT alias &nbsp;n;</p>
            
</td>
         
</tr>
   
</table>
<a name="N125FE"></a><a name="Terms-N125FE"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>n</p>
            
</td>
            <td>
               
<p>The number of tuples.</p>
            
</td>
         
</tr>
   
</table>
<a name="N12625"></a><a name="Usage-N12625"></a>
<h4>Usage</h4>
<p>Use the LIMIT operator to limit the number of output tuples. If the specified number of output tuples is equal to or exceeds the number of tuples in the relation, the output will include all tuples in the relation.</p>
<p>There is no guarantee which tuples will be returned, and the tuples that are returned can change from one run to the next. A particular set of tuples can be requested using the ORDER operator followed by LIMIT.</p>
<p>Note: The LIMIT operator allows Pig to avoid processing all tuples in a relation. In most cases a query that uses LIMIT will run more efficiently than an identical query that does not use LIMIT. It is always a good idea to use limit if you can.</p>
<a name="N12635"></a><a name="Examples-N12635"></a>
<h4>Examples</h4>
<p>Suppose we have relation A.</p>
<pre class="code">
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</pre>
<p>In this example output is limited to 3 tuples. Note that there is no guarantee which three tuples will be output.</p>
<pre class="code">
X = LIMIT A 3;

DUMP X;
(1,2,3)
(4,3,3)
(7,2,5)
</pre>
<p>In this example the ORDER operator is used to order the tuples and the LIMIT operator is used to output the first three tuples.</p>
<pre class="code">
B = ORDER A BY f1 DESC, f2 ASC;

DUMP B;
(8,3,4) 
(8,4,3) 
(7,2,5) 
(4,2,1)
(4,3,3)
(1,2,3)

X = LIMIT B 3;

DUMP X;
(8,3,4)
(8,4,3) 
(7,2,5) 
</pre>
<a name="N1264E"></a><a name="LOAD"></a>
<h3 class="h4">LOAD </h3>
<p>Loads data from the file system.</p>
<a name="N12657"></a><a name="Syntax-N12657"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>LOAD 'data' [USING function] [AS schema];&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N12669"></a><a name="Terms-N12669"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>'data'</p>
            
</td>
            <td>
               
<p>The name of the file or directory, in single quotes.</p>
               
<p>If you specify a directory name, all the files in the directory are loaded. </p>
               
<p>You can use Hadoop-supported globing to specify files at the file system or directory levels (see Hadoop
                  <a href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/fs/FileSystem.html#globStatus(org.apache.hadoop.fs.Path)">gobStatus</a> for details on globing syntax).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>USING</p>
            
</td>
            <td>
               
<p>Keyword. </p>
               
<p>If the USING clause is omitted, the default load function PigStorage is used. </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>function</p>
            
</td>
            <td>
               
<p>The load function. </p>
               
<ul>
                  
<li>
                  
                  
                     
<p>You can use a built-in function (see the <a href="#Load%2FStore+Functions">Load/Store Functions</a>). PigStorage is the default load function and does not need to be specified (simply omit the USING clause).</p>
                  
</li>
                  
<li>
                     
<p>You can write your own load function  
                     if your data is in a format that cannot be processed by the built-in functions (see the <a href="udf.html">Pig UDF Manual</a>).</p>
                  
</li>
               
</ul>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>AS</p>
            
</td>
            <td>
               
<p>Keyword. </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>schema</p>
            
</td>
            <td>
               
<p>A schema using the AS keyword, enclosed in parentheses (see Schemas).</p>
               
<p>The loader produces the data of the type specified by the schema. If the data does not conform to the schema, depending on the loader, either a null value or an error is generated.</p>
               
<p>Note: For performance reasons the loader may not immediately convert the data to the specified format; however, you can still operate on the data assuming the specified type.</p>
            
</td>
         
</tr>
   
</table>
<a name="N126E7"></a><a name="Usage-N126E7"></a>
<h4>Usage</h4>
<p>Use the LOAD operator to load data from the file system. </p>
<a name="N126F0"></a><a name="Examples-N126F0"></a>
<h4>Examples</h4>
<p>Suppose we have a data file called myfile.txt. The fields are tab-delimited. The records are newline-separated.</p>
<pre class="code">
1 2 3
4 2 1
8 3 4
</pre>
<p>In this example the default load function, PigStorage, loads data from myfile.txt to form relation A. The two LOAD statements are equivalent. Note that, because no schema is specified, the fields are not named and all fields default to type bytearray. </p>
<pre class="code">
A = LOAD 'myfile.txt';

A = LOAD 'myfile.txt' USING PigStorage('\t');

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
</pre>
<p>In this example a schema is specified using the AS keyword. The two LOAD statements are equivalent. You can use the DESCRIBE and ILLUSTRATE operators to view the schema. </p>
<pre class="code">
A = LOAD 'myfile.txt' AS (f1:int, f2:int, f3:int);

A = LOAD 'myfile.txt' USING PigStorage(&lsquo;\t&rsquo;) AS (f1:int, f2:int, f3:int);

DESCRIBE A;
a: {f1: int,f2: int,f3: int}

ILLUSTRATE A;
---------------------------------------------------------
| a     | f1: bytearray | f2: bytearray | f3: bytearray |
---------------------------------------------------------
|       | 4             | 2             | 1             |
---------------------------------------------------------

---------------------------------------
| a     | f1: int | f2: int | f3: int |
---------------------------------------
|       | 4       | 2       | 1       |
---------------------------------------
</pre>
<p>
      For examples of how to specify more complex schemas for use with the LOAD operator, see Schemas for Complex Data Types and Schemas for Multiple Types.
      </p>
<a name="N1270B"></a><a name="ORDER"></a>
<h3 class="h4">ORDER</h3>
<p>Sorts a relation based on one or more fields.</p>
<a name="N12714"></a><a name="Syntax-N12714"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias = ORDER alias BY { * [ASC|DESC] | field_alias [ASC|DESC] [, field_alias [ASC|DESC] &hellip;] } [PARALLEL n];</p>
            
</td>
         
</tr>
   
</table>
<a name="N12726"></a><a name="Terms-N12726"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>BY</p>
            
</td>
            <td>
               
<p>Required keyword.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>*</p>
            
</td>
            <td>
               
<p>The designator for a tuple.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>ASC</p>
            
</td>
            <td>
               
<p>Sort in ascending order.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>DESC</p>
            
</td>
            <td>
               
<p>Sort in descending order.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>field_alias</p>
            
</td>
            <td>
               
<p>A field in the relation.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>PARALLEL n</p>
            
</td>
            <td>
               
<p>Increase the parallelism of a job by specifying the number of reduce tasks, n. The default value for n is 1 (one reduce task). Note the following:</p>
               
<ul>
                  
<li>
                     
<p>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </p>
                  
</li>
                  
<li>
                     
<p>If you don&rsquo;t specify parallel, you still get the same map parallelism but only one reduce task. </p>
                  
</li>
               
</ul>
               
<p>For more information, see the <a href="cookbook.html#Use+the+PARALLEL+Clause">Pig Cookbook</a>.</p>
            
</td>
         
</tr>
   
</table>
<a name="N127AE"></a><a name="Usage-N127AE"></a>
<h4>Usage</h4>
<p>In Pig, relations are unordered (see Relations, Bags, Tuples, and Fields):</p>
<ul>
      
<li>
         
<p>If you order relation A to produce relation X (X = ORDER A BY * DESC;) relations A and X still contain the same thing. </p>
      
</li>
      
<li>
         
<p>If you retrieve the contents of relation X (DUMP X;) they are guaranteed to be in the order you specified (descending).</p>
      
</li>
      
<li>
         
<p>However, if you further process relation X (Y = FILTER X BY $0 &gt; 1;) there is no guarantee that the contents will be processed in the order you originally specified (descending).</p>
      
</li>
   
</ul>
<a name="N127CC"></a><a name="Examples-N127CC"></a>
<h4>Examples</h4>
<p>Suppose we have relation A.</p>
<pre class="code">
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</pre>
<p>In this example relation A is sorted by the third field, f3 in descending order. Note that the order of the three tuples ending in 3 can vary.</p>
<pre class="code">
X = ORDER A BY a3 DESC;

DUMP X;
(7,2,5)
(8,3,4)
(1,2,3)
(4,3,3)
(8,4,3)
(4,2,1)
</pre>
<a name="N127DF"></a><a name="SAMPLE"></a>
<h3 class="h4">SAMPLE</h3>
<p>Partitions a relation into two or more relations.</p>
<a name="N127E8"></a><a name="Syntax-N127E8"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>SAMPLE alias size;</p>
            
</td>
         
</tr>
   
</table>
<a name="N127FA"></a><a name="Terms-N127FA"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>size</p>
            
</td>
            <td>
               
<p>Sample size, range 0 to 1 (for example, enter 0.1 for 10%).</p>
            
</td>
         
</tr>
   
</table>
<a name="N12821"></a><a name="Usage-N12821"></a>
<h4>Usage</h4>
<p>Use the SAMPLE operator to select a random data sample with the stated sample size. 
     SAMPLE is a probabalistic operator; there is no guarantee that the exact same number of tuples will be returned for a particular sample size
     each time the operator is used.</p>
<a name="N1282B"></a><a name="Example-N1282B"></a>
<h4>Example</h4>
<p>In this example relation X will contain 1% of the data in relation A.</p>
<pre class="code">
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

X = SAMPLE A 0.01;
</pre>
<a name="N12838"></a><a name="SPLIT"></a>
<h3 class="h4">SPLIT</h3>
<p>Partitions a relation into two or more relations.</p>
<a name="N12841"></a><a name="Syntax-N12841"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>SPLIT alias INTO alias IF expression, alias IF expression [, alias IF expression &hellip;];</p>
            
</td>
         
</tr>
   
</table>
<a name="N12853"></a><a name="Terms-N12853"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>INTO</p>
            
</td>
            <td>
               
<p>Required keyword.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>IF</p>
            
</td>
            <td>
               
<p>Required keyword.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression.</p>
            
</td>
         
</tr>
   
</table>
<a name="N12898"></a><a name="Usage-N12898"></a>
<h4>Usage</h4>
<p>Use the SPLIT operator to partition the contents of a relation into two or more relations based on some expression. Depending on the conditions stated in the expression:</p>
<ul>
      
<li>
         
<p>A tuple may be assigned to more than one relation.</p>
      
</li>
      
<li>
         
<p>A tuple may not be assigned to any relation.</p>
         
<p></p>
         
<p></p>
      
</li>
   
</ul>
<a name="N128B4"></a><a name="Example-N128B4"></a>
<h4>Example</h4>
<p>In this example relation A is split into three relations, X, Y, and Z.</p>
<pre class="code">
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;                
(1,2,3)
(4,5,6)
(7,8,9)        

SPLIT A INTO X IF f1&lt;7, Y IF f2==5, Z IF (f3&lt;6 OR f3&gt;6);

DUMP X;
(1,2,3)
(4,5,6)

DUMP Y;
(4,5,6)

DUMP Z;
(1,2,3)
(7,8,9)
</pre>
<a name="N128C1"></a><a name="STORE"></a>
<h3 class="h4">STORE </h3>
<p>Stores or saves results to the file system.</p>
<a name="N128CA"></a><a name="Syntax-N128CA"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>STORE alias INTO 'directory' [USING function];</p>
            
</td>
         
</tr>
   
</table>
<a name="N128DC"></a><a name="Terms-N128DC"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>INTO</p>
            
</td>
            <td>
               
<p>Required keyword.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>'directory'</p>
            
</td>
            <td>
               
<p>The name of the storage directory, in quotes. If the directory already exists, the STORE operation will fail.</p>
               
<p></p>
               
<p>The output data files, named part-nnnnn, are written to this directory. </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>USING</p>
            
</td>
            <td>
               
<p>Keyword. Use this clause to name the store function.</p>
               
<p>If the USING clause is omitted, the default store function PigStorage is used.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>function</p>
            
</td>
            <td>
               
<p>The store function.</p>
               
<ul>
                  
<li>
                  
                  
                     
<p>You can use a built-in function (see the <a href="#Load%2FStore+Functions">Load/Store Functions</a>). PigStorage is the default store function and does not need to be specified (simply omit the USING clause).</p>
                  
</li>
                  
<li>
                     
<p>You can write your own store function  
                     if your data is in a format that cannot be processed by the built-in functions (see the <a href="udf.html">Pig UDF Manual</a>).</p>
                  
</li>
               
</ul>
            
</td>
         
</tr>
   
</table>
<a name="N1294F"></a><a name="Usage-N1294F"></a>
<h4>Usage</h4>
<p>Use the STORE operator to run (execute) Pig Latin statements and save (persist) results to the file system. Use STORE for production scripts and batch mode processing.</p>
<p>Note: To debug scripts during development, you can use <a href="#DUMP">DUMP</a> to check intermediate results.</p>
<a name="N12960"></a><a name="Examples-N12960"></a>
<h4>Examples</h4>
<p>In this example data is stored using PigStorage and the asterisk character (*) as the field delimiter.</p>
<pre class="code">
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

STORE A INTO 'myoutput' USING PigStorage ('*');

CAT myoutput;
1*2*3
4*2*1
8*3*4
4*3*3
7*2*5
8*4*3
</pre>
<p>In this example, the CONCAT function is used to format the data before it is stored.</p>
<pre class="code">
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = FOREACH A GENERATE CONCAT('a:',(chararray)f1), CONCAT('b:',(chararray)f2), CONCAT('c:',(chararray)f3);

DUMP B;
(a:1,b:2,c:3)
(a:4,b:2,c:1)
(a:8,b:3,c:4)
(a:4,b:3,c:3)
(a:7,b:2,c:5)
(a:8,b:4,c:3)

STORE B INTO 'myoutput' using PigStorage(',');

CAT myoutput;
a:1,b:2,c:3
a:4,b:2,c:1
a:8,b:3,c:4
a:4,b:3,c:3
a:7,b:2,c:5
a:8,b:4,c:3
</pre>
<a name="N12973"></a><a name="STREAM"></a>
<h3 class="h4">STREAM</h3>
<p>Sends data to an external script or program.</p>
<a name="N1297C"></a><a name="Syntax-N1297C"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias = STREAM alias [, alias &hellip;] THROUGH {'command' | cmd_alias }&nbsp;[AS schema] ;</p>
            
</td>
         
</tr>
   
</table>
<a name="N1298E"></a><a name="Terms-N1298E"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>THROUGH</p>
            
</td>
            <td>
               
<p>Keyword. </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>'command'</p>
            
</td>
            <td>
               
<p>A command, including the arguments, enclosed in back tics (where a command is anything that can be executed).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>cmd_alias</p>
            
</td>
            <td>
               
<p>The name of a command created using the <a href="#DEFINE">DEFINE</a> operator (see the DEFINE operator for additional  streaming examples).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>AS</p>
            
</td>
            <td>
               
<p>Keyword.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>schema</p>
            
</td>
            <td>
               
<p>A schema using the AS keyword, enclosed in parentheses (see Schemas).</p>
            
</td>
         
</tr>
   
</table>
<a name="N129F5"></a><a name="Usage-N129F5"></a>
<h4>Usage</h4>
<p>Use the STREAM operator to send data through an external script or program. Multiple stream operators can appear in the same Pig script. The stream operators can be adjacent to each other or have other operations in between.</p>
<p>When used with a command, a stream statement could look like this:</p>
<pre class="code">
A = LOAD 'data';

B = STREAM A THROUGH 'stream.pl -n 5';
</pre>
<p>When used with a cmd_alias, a stream statement could look like this, where mycmd is the defined alias.</p>
<pre class="code">
A = LOAD 'data';

DEFINE mycmd 'stream.pl &ndash;n 5';

B = STREAM A THROUGH mycmd;
</pre>
<a name="N12A0B"></a><a name="About+Data+Guarantees"></a>
<h4>About Data Guarantees</h4>
<p>Data guarantees are determined based on the position of the streaming operator in the Pig script. </p>
<ul>
      
<li>
         
<p>Unordered data &ndash; No guarantee for the order in which the data is delivered to the streaming application. </p>
      
</li>
      
<li>
         
<p>Grouped data &ndash; The data for the same grouped key is guaranteed to be provided to the streaming application contiguously</p>
      
</li>
      
<li>
         
<p>Grouped and ordered data &ndash; The data for the same grouped key is guaranteed to be provided to the streaming application contiguously. Additionally, the data within the group is guaranteed to be sorted by the provided secondary key.</p>
      
</li>
   
</ul>
<p>In addition to position, data grouping and ordering can be determined by the data itself. However, you need to know the property of the data to be able to take advantage of its structure.</p>
<a name="N12A2D"></a><a name="Example%3A+Data+Guarantees"></a>
<h4>Example: Data Guarantees</h4>
<p>In this example the data is unordered.</p>
<pre class="code">
A = LOAD 'data';

B = STREAM A THROUGH 'stream.pl';
</pre>
<p>In this example the data is grouped.</p>
<pre class="code">
A = LOAD 'data';

B = GROUP A BY $1;

C = FOREACH B FLATTEN(A);

D = STREAM C THROUGH 'stream.pl';
</pre>
<p>In this example the data is grouped and ordered.</p>
<pre class="code">
A = LOAD 'data';

B = GROUP A BY $1;

C = FOREACH B {
      D = ORDER A BY ($3, $4);
      GENERATE D;
}

E = STREAM C THROUGH 'stream.pl';
</pre>
<a name="N12A46"></a><a name="Example%3A+Schemas"></a>
<h4>Example: Schemas</h4>
<p>In this example a schema is specified as part of the STREAM statement.</p>
<pre class="code">
X = STREAM A THROUGH 'stream.pl' as (f1:int, f2;int, f3:int);
</pre>
<a name="N12A54"></a><a name="UNION"></a>
<h3 class="h4">UNION</h3>
<p>Computes the union of two or more relations.</p>
<a name="N12A5D"></a><a name="Syntax-N12A5D"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias = UNION alias, alias [, alias &hellip;];</p>
            
</td>
         
</tr>
   
</table>
<a name="N12A6F"></a><a name="Terms-N12A6F"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
   
</table>
<a name="N12A87"></a><a name="Usage-N12A87"></a>
<h4>Usage</h4>
<p>Use the UNION operator to merge the contents of two or more relations. The UNION operator:</p>
<ul>
      
<li>
         
<p>Does not preserve the order of tuples. Both the input and output relations are interpreted as unordered bags of tuples.</p>
      
</li>
      
<li>
         
<p>Does not ensure (as databases do) that all tuples adhere to the same schema or that they have the same number of fields. In a typical scenario, however, this should be the case; therefore, it is the user's responsibility to either (1) ensure that the tuples in the input relations have the same schema or (2) be able to process varying tuples in the output relation.</p>
      
</li>
      
<li>
         
<p>Does not eliminate duplicate tuples.</p>
      
</li>
   
</ul>
<a name="N12AA5"></a><a name="Example-N12AA5"></a>
<h4>Example</h4>
<p>In this example the union of relation A and B is computed.</p>
<pre class="code">
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)

B = LOAD 'data' AS (b1:int,b2:int);

DUMP A;
(2,4)
(8,9)
(1,3)

X = UNION A, B;

DUMP X;
(1,2,3)
(4,2,1)
(2,4)
(8,9)
(1,3)
</pre>
</div>


 <!-- DIAGNOSTIC OPERATORS -->    

<a name="N12AB4"></a><a name="Diagnostic+Operators"></a>
<h2 class="h3">Diagnostic Operators</h2>
<div class="section">
<a name="N12ABA"></a><a name="DESCRIBE"></a>
<h3 class="h4">DESCRIBE</h3>
<p>Returns the schema of an alias.</p>
<a name="N12AC3"></a><a name="Syntax-N12AC3"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>DESCRIBE alias;&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N12AD5"></a><a name="Terms-N12AD5"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
   
</table>
<a name="N12AED"></a><a name="Usage-N12AED"></a>
<h4>Usage</h4>
<p>Use the DESCRIBE operator to review the schema of a particular alias.</p>
<a name="N12AF6"></a><a name="Example-N12AF6"></a>
<h4>Example</h4>
<p>In this example a schema is specified using the AS clause. If all data conforms to the schema, Pig will use the assigned types.</p>
<pre class="code">
A = LOAD 'student' AS (name:chararray, age:int, gpa:float);

B = FILTER A BY name matches 'J.+';

C = GROUP B BY name;

D = FOREACH B GENERATE COUNT(B.age);

DESCRIBE A;
A: {group, B: (name: chararray,age: int,gpa: float}

DESCRIBE B;
B: {group, B: (name: chararray,age: int,gpa: float}

DESCRIBE C;
C: {group, chararry,B: (name: chararray,age: int,gpa: float}

DESCRIBE D;
D: {long}
</pre>
<p>In this example no schema is specified. All fields default to type bytearray or long (see Data Types).</p>
<pre class="code">
a = LOAD 'student';

b = FILTER a BY $0 matches 'J.+';

c = GROUP b BY $0;

d = FOREACH c GENERATE COUNT(b.$1);

DESCRIBE a;
Schema for a unknown.

DESCRIBE b;
2008-12-05 01:17:15,316 [main] WARN  org.apache.pig.PigServer - bytearray is implicitly cast to chararray under LORegexp Operator
Schema for b unknown.

DESCRIBE c;
2008-12-05 01:17:23,343 [main] WARN  org.apache.pig.PigServer - bytearray is implicitly caste to chararray under LORegexp Operator
c: {group: bytearray,b: {null}}

DESCRIBE d;
2008-12-05 03:04:30,076 [main] WARN  org.apache.pig.PigServer - bytearray is implicitly caste to chararray under LORegexp Operator
d: {long}
</pre>
<a name="N12B09"></a><a name="DUMP"></a>
<h3 class="h4">DUMP</h3>
<p>Dumps or displays results to screen.</p>
<a name="N12B12"></a><a name="Syntax-N12B12"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>DUMP alias;&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N12B24"></a><a name="Terms-N12B24"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
   
</table>
<a name="N12B3C"></a><a name="Usage-N12B3C"></a>
<h4>Usage</h4>
<p>Use the DUMP operator to run (execute) Pig Latin statements and display the results to your screen. DUMP is meant for interactive mode; statements are executed immediately and the results are not saved (persisted). You can use DUMP as a debugging device to make sure that the results you are expecting are actually generated. </p>
<p>
   Note that production scripts <em>should not</em> use DUMP as it will disable multi-query optimizations and is likely to slow down execution 
   (see <a href="piglatin_ref1.html#Store+vs.+Dump">Store vs. Dump</a>).
   </p>
<a name="N12B50"></a><a name="Example-N12B50"></a>
<h4>Example</h4>
<p>In this example a dump is performed after each statement.</p>
<pre class="code">
A = LOAD 'student' AS (name:chararray, age:int, gpa:float);

DUMP A;
(John,18,4.0F)
(Mary,19,3.7F)
(Bill,20,3.9F)
(Joe,22,3.8F)
(Jill,20,4.0F)

B = FILTER A BY name matches 'J.+';

DUMP B;
(John,18,4.0F)
(Joe,22,3.8F)
(Jill,20,4.0F)
</pre>
<a name="N12B5D"></a><a name="EXPLAIN"></a>
<h3 class="h4">EXPLAIN</h3>
<p>Displays execution plans.</p>
<a name="N12B66"></a><a name="Syntax-N12B66"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>EXPLAIN [&ndash;script pigscript] [&ndash;out path] [&ndash;brief] [&ndash;dot] [&ndash;param param_name = param_value] [&ndash;param_file file_name] alias;&nbsp;</p>
            
</td>
         
</tr>
   
</table>
<a name="N12B78"></a><a name="Terms-N12B78"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
   
         
<tr>
            
<td>
               
<p>&ndash;script</p>
            
</td>
            <td>
               
<p>Use to specify a pig script.</p>
            
</td>
         
</tr>      

         
<tr>
            
<td>
               
<p>&ndash;out</p>
            
</td>
            <td>
               
<p>Use to specify the output path (directory).</p>
               
<p>Will generate a logical_plan[.txt|.dot], physical_plan[.text|.dot], exec_plan[.text|.dot] file in the specified path.</p>
               
<p>Default (no path specified): Stdout </p>
            
</td>
         
</tr>

         
<tr>
            
<td>
               
<p>&ndash;brief</p>
            
</td>
            <td>
               
<p>Does not expand nested plans (presenting a smaller graph for overview). </p>
            
</td>
         
</tr>
         
         
<tr>
            
<td>
               
<p>&ndash;dot</p>
            
</td>
            <td>

               
<p>Text mode (default): multiple output (split) will be broken out in sections.  </p>
               
<p>Dot mode: outputs a format that can be passed to the dot utility for graphical display &ndash; 
               will generate a directed-acyclic-graph (DAG) of the plans in any supported format (.gif, .jpg ...).</p>
            
</td>
         
</tr>

         
<tr>
            
<td>
               
<p>&ndash;param param_name = param_value</p>
            
</td>
            <td>
               
<p>See Parameter Substitution.</p>
            
</td>
         
</tr>

         
<tr>
            
<td>
               
<p>&ndash;param_file file_name</p>
            
</td>
            <td>
               
<p>See Parameter Substitution. </p>
            
</td>
         
</tr>
      
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
         
   
   
</table>
<a name="N12BF3"></a><a name="Usage-N12BF3"></a>
<h4>Usage</h4>
<p>Use the EXPLAIN operator to review the logical, physical, and map reduce execution plans that are used to compute the specified relationship. </p>
<p>If no script is given:</p>
<ul>	
      
<li>
         
<p>The logical plan shows a pipeline of operators to be executed to build the relation. Type checking and backend-independent optimizations (such as applying filters early on) also apply.</p>
      
</li>
      
<li>
         
<p>The physical plan shows how the logical operators are translated to backend-specific physical operators. Some backend optimizations also apply.</p>
      
</li>
      
<li>
         
<p>The map reduce plan shows how the physical operators are grouped into map reduce jobs.</p>
      
</li>
  
</ul>
<p></p>
<p>If a script without an alias is specified, it will output the entire execution graph (logical, physical, or map reduce). </p>
<p>If a script with a alias is specified, it will output the plan for the given alias. </p>
<a name="N12C1D"></a><a name="Example-N12C1D"></a>
<h4>Example</h4>
<p>In this example the EXPLAIN operator produces all three plans. (Note that only a portion of the output is shown in this example.)</p>
<pre class="code">
A = LOAD 'student' AS (name:chararray, age:int, gpa:float);

B = GROUP A BY name;

C = FOREACH B GENERATE COUNT(A.age);

EXPLAIN C;
-----------------------------------------------
Logical Plan:
-----------------------------------------------
Store xxx-Fri Dec 05 19:42:29 UTC 2008-23 Schema: {long} Type: Unknown
|
|---ForEach xxx-Fri Dec 05 19:42:29 UTC 2008-15 Schema: {long} Type: bag
<em>etc &hellip;</em>

-----------------------------------------------
Physical Plan:
-----------------------------------------------
Store(fakefile:org.apache.pig.builtin.PigStorage) - xxx-Fri Dec 05 19:42:29 UTC 2008-40
|
|---New For Each(false)[bag] - xxx-Fri Dec 05 19:42:29 UTC 2008-39
    |   |
    |   POUserFunc(org.apache.pig.builtin.COUNT)[long] - xxx-Fri Dec 05 
<em>etc &hellip;</em>

--------------------------------------------------
| Map Reduce Plan                               
-------------------------------------------------
MapReduce node xxx-Fri Dec 05 19:42:29 UTC 2008-41
Map Plan
Local Rearrange[tuple]{chararray}(false) - xxx-Fri Dec 05 19:42:29 UTC 2008-34
|   |
|   Project[chararray][0] - xxx-Fri Dec 05 19:42:29 UTC 2008-35
<em>etc &hellip;</em>
</pre>
<a name="N12C32"></a><a name="ILLUSTRATE"></a>
<h3 class="h4">ILLUSTRATE</h3>
<p>(Note! This feature is NOT maintained at the moment. We are looking for someone to adopt it.)</p>
<p>Displays a step-by-step execution of a sequence of statements.</p>
<a name="N12C3E"></a><a name="Syntax-N12C3E"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>ILLUSTRATE alias;&nbsp;</p>
            
</td>
         
</tr>
   
</table>
<a name="N12C50"></a><a name="Terms-N12C50"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name of a relation.</p>
            
</td>
         
</tr>
   
</table>
<a name="N12C68"></a><a name="Usage-N12C68"></a>
<h4>Usage</h4>
<p>Use the ILLUSTRATE operator to review how data is transformed through a sequence of Pig Latin statements:</p>
<ul>
      
<li>
         
<p>The data load statement must include a schema.</p>
      
</li>
      
<li>
         
<p>The Pig Latin statement used to form the relation that is used with the ILLUSTRATE command cannot include the map data type, the LIMIT and SPLIT operators, or nested FOREACH statements. </p>
      
</li>
   
</ul>
<p>ILLUSTRATE accesses the ExampleGenerator algorithm which can select an appropriate and concise set of example data automatically. It does a better job than random sampling would do; for example, random sampling suffers from the drawback that selective operations such as filters or joins can eliminate all the sampled data, giving you empty results which will not help with debugging. </p>
<p>With the ILLUSTRATE operator you can test your programs on small datasets and get faster turnaround times. The ExampleGenerator algorithm uses Pig's Local mode (rather than Hadoop mode) which means that illustrative example data is generated in near real-time.</p>
<p>Relation X can be used with the ILLUSTRATE operator.</p>
<pre class="code">
X = FOREACH A GENERATE f1;

ILLUSTRATE X;
</pre>
<p>Relation Y cannot be used with the ILLUSTRATE operator.</p>
<pre class="code">
Y = LIMIT A 3;

ILLUSTRATE Y;
</pre>
<a name="N12C93"></a><a name="Example-N12C93"></a>
<h4>Example</h4>
<p>In this example we count the number of sites a user has visited since 12/1/08. The ILLUSTRATE statement will show how the results for num_user_visits are derived.</p>
<pre class="code">
visits = LOAD 'visits' AS (user:chararray, ulr:chararray, timestamp:chararray);

DUMP visits;
(Amy,cnn.com,20080218)
(Fred,harvard.edu,20081204)
(Amy,bbc.com,20081205)
(Fred,stanford.edu,20081206)

recent_visits = FILTER visits BY timestamp &gt;= '20081201';

user_visits = GROUP recent_visits BY user;

num_user_visits = FOREACH user_visits GENERATE COUNT(recent_visits);

DUMP num_user_visits;
(1L)
(2L)

ILLUSTRATE num_user_visits;
------------------------------------------------------------------------
| visits     | user: bytearray | ulr: bytearray | timestamp: bytearray |
------------------------------------------------------------------------
|            | Amy             | cnn.com        | 20080218             |
|            | Fred            | harvard.edu    | 20081204             |
|            | Amy             | bbc.com        | 20081205             |
|            | Fred            | stanford.edu   | 20081206             |
------------------------------------------------------------------------

------------------------------------------------------------------------
| visits     | user: chararray | ulr: chararray | timestamp: chararray |
------------------------------------------------------------------------
|            | Amy             | cnn.com        | 20080218             |
|            | Fred            | harvard.edu    | 20081204             |
|            | Amy             | bbc.com        | 20081205             |
|            | Fred            | stanford.edu   | 20081206             |
------------------------------------------------------------------------

-------------------------------------------------------------------------------
| recent_visits     | user: chararray | ulr: chararray | timestamp: chararray |
-------------------------------------------------------------------------------
|                   | Fred            | harvard.edu    | 20081204             |
|                   | Amy             | bbc.com        | 20081205             |
|                   | Fred            | stanford.edu   | 20081206             |
-------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------
| user_visits     | group: chararray | recent_visits: bag({user: chararray,ulr: chararray,timestamp: chararray}) |
------------------------------------------------------------------------------------------------------------------
|                 | Amy              | {(Amy, bbc.com, 20081205)}                                                |
|                 | Fred             | {(Fred, harvard.edu, 20081204), (Fred, stanford.edu, 20081206)}           |
------------------------------------------------------------------------------------------------------------------

-------------------------------
| num_user_visits     | long  |
------------------------------
|                     | 1     |
|                     | 2     |
-------------------------------
</pre>
</div>
   
   
    <!-- UDF STATEMENTS --> 
   
<a name="N12CA3"></a><a name="UDF+Statements"></a>
<h2 class="h3">UDF Statements</h2>
<div class="section">
<a name="N12CA9"></a><a name="DEFINE"></a>
<h3 class="h4">DEFINE</h3>
<p>Assigns an alias to a UDF function or a streaming command.</p>
<a name="N12CB2"></a><a name="Syntax-N12CB2"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>DEFINE alias {function | [`command` [input] [output] [ship] [cache]] };</p>
            
</td>
         
</tr>
   
</table>
<a name="N12CC4"></a><a name="Terms-N12CC4"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The name for a UDF function or the name for a streaming command (the cmd_alias for the <a href="#STREAM">STREAM</a> operator). </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>function</p>
            
</td>
            <td>
            
<p>For use with functions.</p>
               
<p>The name of a UDF function. </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>`command`</p>
            
</td>
            <td>
            
<p>For use with streaming.</p>
               
<p>A command, including the arguments, enclosed in back tics (where a command is anything that can be executed).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>input</p>
            
</td>
            <td>
                
<p>For use with streaming.</p>
               
<p>INPUT ( {stdin | 'path'} [USING serializer] [, {stdin | 'path'} [USING serializer] &hellip;] )</p>
               
<p>Where:</p>
               
<ul>
                  
<li>
                     
<p>INPUT &ndash; Keyword.</p>
                  
</li>
                  
<li>
                     
<p>'path' &ndash; A file path, enclosed in single quotes.</p>
                  
</li>
                  
<li>
                     
<p>USING &ndash; Keyword.</p>
                  
</li>
                  
<li>
                     
<p>serializer &ndash; PigStreaming is the default serializer. </p>
                  
</li>
               
</ul>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>output</p>
            
</td>
            <td>
            
<p>For use with streaming.</p>
               
<p>OUTPUT ( {stdout | stderr | 'path'} [USING deserializer] [, {stdout | stderr | 'path'} [USING deserializer] &hellip;] )</p>
               
<p>Where:</p>
               
<ul>
                  
<li>
                     
<p>OUTPUT &ndash; Keyword.</p>
                  
</li>
                  
<li>
                     
<p>'path' &ndash; A file path, enclosed in single quotes.</p>
                  
</li>
                  
<li>
                     
<p>USING &ndash; Keyword.</p>
                  
</li>
                  
<li>
                     
<p>deserializer &ndash; PigStreaming is the default deserializer. </p>
                  
</li>
               
</ul>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>ship</p>
            
</td>
            <td>
            
<p>For use with streaming.</p>
               
<p>SHIP('path' [, 'path' &hellip;])</p>
               
<p>Where:</p>
               
<ul>
                  
<li>
                     
<p>SHIP &ndash; Keyword.</p>
                  
</li>
                  
<li>
                     
<p>'path' &ndash; A file path, enclosed in single quotes.</p>
                  
</li>
               
</ul>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>cache</p>
            
</td>
            <td>
            
<p>For use with streaming.</p>
               
<p>CACHE('dfs_path#dfs_file' [, 'dfs_path#dfs_file' &hellip;])</p>
               
<p>Where:</p>
               
<ul>
                  
<li>
                     
<p>CACHE &ndash; Keyword.</p>
                  
</li>
                  
<li>
                     
<p>'dfs_path#dfs_file' &ndash; A file path/file name on the distributed file system, enclosed in single quotes. Example: '/mydir/mydata.txt#mydata.txt'</p>
                  
</li>
               
</ul>
            
</td>
         
</tr>
   
</table>
<a name="N12DAC"></a><a name="Usage-N12DAC"></a>
<h4>Usage</h4>
<p>Use the DEFINE statement to assign a name (alias) to a UDF function or to a streaming command.</p>
<p>Use DEFINE to specify a UDF function when:</p>
<ul>
      
<li>
         
<p>The function has a long package name that you don't want to include in a script, especially if you call the function several times in that script.</p>
      
</li>
      
<li>
         
<p>The constructor for the function takes string parameters. If you need to use different constructor parameters for different calls to the function you will need to create multiple defines &ndash; one for each parameter set.</p>
      
</li>
   
</ul>
<p>Use DEFINE to specify a streaming command when: </p>
<ul>
   
<li>
   
<p>The streaming command specification is complex.</p>
   
</li>
      
<li>
   
<p>The streaming command specification requires additional parameters (input, output, and so on).</p>
   
</li>
   
</ul>
<a name="N12DD9"></a><a name="About+Input+and+Output"></a>
<h5>About Input and Output</h5>
<p>Serialization is needed to convert data from tuples to a format that can be processed by the streaming application. Deserialization is needed to convert the output from the streaming application back into tuples. PigStreaming is the default serialization/deserialization function.</p>
<p>Streaming uses the same default format as PigStorage to serialize/deserialize the data. If you want to explicitly specify a format, you can do it as show below (see more examples in the Examples: Input/Output section).  </p>
<pre class="code">
DEFINE CMD 'perl PigStreaming.pl - nameMap' input(stdin using PigStreaming(',')) output(stdout using PigStreaming(','));
A = LOAD 'file';
B = STREAM B THROUGH CMD;
</pre>
<p>If you need an alternative format, you will need to create a custom serializer/deserializer by implementing the following interfaces.</p>
<pre class="code">
interface PigToStream {

        /**
         * Given a tuple, produce an array of bytes to be passed to the streaming
         * executable.
         */
        public byte[] serialize(Tuple t) throws IOException;
    }

    interface StreamToPig {

        /**
         *  Given a byte array from a streaming executable, produce a tuple.
         */
        public Tuple deserialize(byte[]) throws IOException;

        /**
         * This will be called on the front end during planning and not on the back
         * end during execution.
         *
         * @return the {@link LoadCaster} associated with this object.
         * @throws IOException if there is an exception during LoadCaster
         */
        public LoadCaster getLoadCaster() throws IOException;
    }
</pre>
<a name="N12DEF"></a><a name="About+Ship"></a>
<h5>About Ship </h5>
<p>Use the ship option to send streaming binary and supporting files, if any, from the client node to the compute nodes. Pig does not automatically ship dependencies; it is your responsibility to explicitly specify all the dependencies and to make sure that the software the processing relies on (for instance, perl or python) is installed on the cluster. Supporting files are shipped to the task's current working directory and only relative paths should be specified. Any pre-installed binaries should be specified in the PATH. </p>
<p>Only files, not directories, can be specified with the ship option. One way to work around this limitation is to tar all the dependencies into a tar file that accurately reflects the structure needed on the compute nodes, then have a wrapper for your script that un-tars the dependencies prior to execution.</p>
<p>Note that the ship option has two components: the source specification, provided in the ship( ) clause, is the view of your machine; the command specification is the view of the actual cluster. The only guarantee is that the shipped files are available in the current working directory of the launched job and that your current working directory is also on the PATH environment variable. </p>
<p>Shipping files to relative paths or absolute paths is not supported since you might not have permission to read/write/execute from arbitrary paths on the clusters.</p>
<p>Note the following:</p>
<ol>
		
<li>
			
<p>It is safe only to ship files to be executed from the current working directory on the task on the cluster.</p>
			
<pre class="code">
OP = stream IP through 'script';
or
DEFINE CMD 'script' ship('/a/b/script');
OP = stream IP through 'CMD';
</pre>
		
</li>
	    
<li>
			
<p>Shipping files to relative paths or absolute paths is undefined and mostly will fail since you may not have permissions to read/write/execute from arbitraty paths on the actual clusters. </p>
	    
</li>
	
</ol>
<a name="N12E17"></a><a name="About+Cache"></a>
<h5>About Cache</h5>
<p>The ship option works with binaries, jars, and small datasets. However, loading larger datasets at run time for every execution can severely impact performance. Instead, use the cache option to access large files already moved to and available on the compute nodes. Only files, not directories, can be specified with the cache option.</p>
<a name="N12E21"></a><a name="autoship"></a>
<h5>About Auto-Ship</h5>
<p>If the ship and cache options are not specified, Pig will attempt to auto-ship the binary in the following way:</p>
<ul>
		
<li>
            
<p>If the first word on the streaming command is perl or python, Pig assumes that the binary is the first non-quoted string it encounters that does not start with dash.</p>
		
</li>
		
<li>
			
<p>Otherwise, Pig will attempt to ship the first string from the command line as long as it does not come from <span class="codefrag computeroutput">/bin, /usr/bin, /usr/local/bin</span>. Pig will determine this by scanning the path if an absolute path is provided or by executing  <span class="codefrag computeroutput">which</span>. The paths can be made configurable using the <a href="#set">set stream.skippath</a> option (you can use multiple set commands to specify more than one path to skip). </p>
		
</li>
	
</ul>
<p>If you don't supply a DEFINE for a given streaming command, then auto-shipping is turned off.</p>
<p>Note the following:</p>
<ol>
		
<li>
			
<p>If Pig determines that it needs to auto-ship an absolute path it will not ship it at all since there is no way to ship files to the necessary location (lack of permissions and so on). </p>
			
<pre class="code">
OP = stream IP through '/a/b/c/script';
or 
OP = stream IP through 'perl /a/b/c/script.pl';
</pre>
		
</li>
	    
<li>
			
<p>Pig will not auto-ship files in the following system directories (this is determined by executing 'which &lt;file&gt;' command). </p>
			
<pre class="code">
/bin /usr/bin /usr/local/bin /sbin /usr/sbin /usr/local/sbin
</pre>
		
</li>
	    
<li>
			
<p>To auto-ship, the file in question should be present in the PATH. So if the file is in the current working directory then the current working directory should be in the PATH. </p>
		
</li>
	
</ol>
<a name="N12E68"></a><a name="Examples%3A+Input%2FOutput"></a>
<h4>Examples: Input/Output</h4>
<p>In this example PigStreaming is the default serialization/deserialization function. The tuples from relation A are converted to tab-delimited lines that are passed to the script.</p>
<pre class="code">
X = STREAM A THROUGH 'stream.pl';
</pre>
<p>In this example PigStreaming is used as the serialization/deserialization function, but a comma is used as the delimiter.</p>
<pre class="code">
DEFINE Y 'stream.pl' INPUT(stdin USING PigStreaming(',')) OUTPUT (stdout USING PigStreaming(','));

X = STREAM A THROUGH Y;
</pre>
<p>In this example user-defined serialization/deserialization functions are used with the script.</p>
<pre class="code">
DEFINE Y 'stream.pl' INPUT(stdin USING MySerializer) OUTPUT (stdout USING MyDeserializer);

X = STREAM A THROUGH Y;
</pre>
<a name="N12E81"></a><a name="Examples%3A+Ship%2FCache"></a>
<h4>Examples: Ship/Cache</h4>
<p>In this example ship is used to send the script to the cluster compute nodes.</p>
<pre class="code">
DEFINE Y 'stream.pl' SHIP('/work/stream.pl');

X = STREAM A THROUGH Y;
</pre>
<p>In this example cache is used to specify a file located on the cluster compute nodes.</p>
<pre class="code">
DEFINE Y 'stream.pl data.gz' SHIP('/work/stream.pl') CACHE('/input/data.gz#data.gz');

X = STREAM A THROUGH Y;
</pre>
<a name="N12E95"></a><a name="Example%3A+DEFINE+with+STREAM"></a>
<h3 class="h4">Example: DEFINE with STREAM</h3>
<p>In this example a command is defined for use with the <a href="#STREAM">STREAM</a> operator.</p>
<pre class="code">
A = LOAD 'data';

DEFINE mycmd 'stream_cmd &ndash;input file.dat';

B = STREAM A through mycmd;
</pre>
<a name="N12EA6"></a><a name="Examples%3A+Logging"></a>
<h3 class="h4">Examples: Logging</h3>
<p>In this example the streaming stderr is stored in the _logs/&lt;dir&gt; directory of the job's output directory. Because the job can have multiple streaming applications associated with it, you need to ensure that different directory names are used to avoid conflicts. Pig stores up to 100 tasks per streaming job.</p>
<pre class="code">
DEFINE Y 'stream.pl' stderr('&lt;dir&gt;' limit 100);

X = STREAM A THROUGH Y;
</pre>
<p>In this example a function is defined for use with the FOREACH &hellip;GENERATE operator.</p>
<pre class="code">
REGISTER /src/myfunc.jar

DEFINE myFunc myfunc.MyEvalfunc('foo');

A = LOAD 'students';

B = FOREACH A GENERATE myFunc($0);
</pre>
<a name="N12EB9"></a><a name="REGISTER"></a>
<h3 class="h4">REGISTER</h3>
<p>Registers a JAR file so that the UDFs in the file can be used.</p>
<a name="N12EC2"></a><a name="Syntax-N12EC2"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>REGISTER alias;</p>
            
</td>
         
</tr>
   
</table>
<a name="N12ED4"></a><a name="Terms-N12ED4"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>alias</p>
            
</td>
            <td>
               
<p>The path of a Java JAR file. Do not place the name in quotes.</p>
            
</td>
         
</tr>
   
</table>
<a name="N12EEC"></a><a name="Usage-N12EEC"></a>
<h4>Usage</h4>
<p>Use the REGISTER statement inside a Pig script to specify the path of a Java JAR file containing UDFs. </p>
<p>You can register additional files (to use with your Pig script) via the command line using the -Dpig.additional.jars option.</p>
<p>For more information about UDFs, see the User Defined Function Guide. Note that Pig currently only supports functions written in Java.</p>
<a name="N12EFB"></a><a name="Example-N12EFB"></a>
<h4>Example</h4>
<p>In this example REGISTER states that myfunc.jar is located in the /src directory.</p>
<pre class="code">
/src $ java -jar pig.jar &ndash;

REGISTER /src/myfunc.jar;
A = LOAD 'students';
B = FOREACH A GENERATE myfunc.MyEvalFunc($0);
</pre>
<p>In this example additional jar files are registered via the command line.</p>
<pre class="code">
pig -Dpig.additional.jars=my.jar:your.jar script.pig
</pre>
<p></p>
</div>
   
   <!-- BUILT-IN FUNCTIONS --> 
    
    
<a name="N12F12"></a><a name="Eval+Functions"></a>
<h2 class="h3">Eval Functions</h2>
<div class="section">
<a name="N12F17"></a><a name="AVG"></a>
<h3 class="h4">AVG</h3>
<p>Computes the average of the numeric values in a single-column bag. </p>
<a name="N12F20"></a><a name="Syntax-N12F20"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>AVG(expression)</p>
            
</td>
         
</tr>
   
</table>
<a name="N12F31"></a><a name="Terms-N12F31"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>Any expression whose result is a bag. The elements of the bag should be data type int, long, float, or double.</p>
            
</td>
         
</tr>
   
</table>
<a name="N12F49"></a><a name="Usage-N12F49"></a>
<h4>Usage</h4>
<p>Use the AVG function to compute the average of the numeric values in a single-column bag. 
   AVG requires a preceding GROUP ALL statement for global averages and a GROUP BY statement for group averages.</p>
<p>The AVG function now ignores NULL values. </p>
<a name="N12F56"></a><a name="Example-N12F56"></a>
<h4>Example</h4>
<p>In this example the average GPA for each student is computed (see the GROUP operators for information about the field names in relation B).</p>
<pre class="code">
A = LOAD 'student.txt' AS (name:chararray, term:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

C = FOREACH B GENERATE A.name, AVG(A.gpa);

DUMP C;
({(John),(John),(John),(John)},3.850000023841858)
({(Mary),(Mary),(Mary),(Mary)},3.925000011920929)
</pre>
<a name="N12F63"></a><a name="Types+Tables"></a>
<h4>Types Tables</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>AVG </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as double </p>
            
</td>
         
</tr>
   
</table>
<a name="N12FC5"></a><a name="CONCAT"></a>
<h3 class="h4">CONCAT</h3>
<p>Concatenates two fields of type chararray or two fields of type bytearray.</p>
<a name="N12FCE"></a><a name="Syntax-N12FCE"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>CONCAT (expression, expression)</p>
            
</td>
         
</tr>
   
</table>
<a name="N12FE0"></a><a name="Terms-N12FE0"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression with data types chararray or bytearray.</p>
            
</td>
         
</tr>
   
</table>
<a name="N12FF8"></a><a name="Usage-N12FF8"></a>
<h4>Usage</h4>
<p>Use the CONCAT function to concatenate two elements. The data type of the two elements must be the same, either chararray or bytearray.</p>
<a name="N13001"></a><a name="Example-N13001"></a>
<h4>Example</h4>
<p>In this example fields f2 and f3 are concatenated.</p>
<pre class="code">
A = LOAD 'data' as (f1:chararray, f2:chararray, f3:chararray);

DUMP A;
(apache,open,source)
(hadoop,map,reduce)
(pig,pig,latin)

X = FOREACH A GENERATE CONCAT(f2,f3);

DUMP X;
(opensource)
(mapreduce)
(piglatin)
</pre>
<a name="N1300E"></a><a name="Types+Tables-N1300E"></a>
<h4>Types Tables</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>cast as chararray &nbsp;</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray </p>
            
</td>
            <td>
               
<p></p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
   
</table>
<a name="N13054"></a><a name="COUNT"></a>
<h3 class="h4">COUNT</h3>
<p>Computes the number of elements in a bag. </p>
<a name="N1305D"></a><a name="Syntax-N1305D"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>COUNT(expression) </p>
            
</td>
         
</tr>
   
</table>
<a name="N1306F"></a><a name="Terms-N1306F"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression with data type bag.</p>
            
</td>
         
</tr>
   
</table>
<a name="N13087"></a><a name="Usage-N13087"></a>
<h4>Usage</h4>
<p>Use the COUNT function to compute the number of elements in a bag.
   COUNT requires a preceding GROUP ALL statement for global counts and a GROUP BY statement for group counts.</p>
<p>
    The COUNT function ignores NULL values.  If you want to include NULL values in the count computation, use 
    <a href="#COUNT_STAR">COUNT_STAR</a>.
   </p>
<p>
    Note: You cannot use the tuple designator (*) with COUNT; that is, COUNT(*) will not work.   
   </p>
<a name="N1309B"></a><a name="Example-N1309B"></a>
<h4>Example</h4>
<p>In this example the tuples in the bag are counted (see the GROUP operator for information about the field names in relation B).</p>
<pre class="code">
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

X = FOREACH B GENERATE COUNT(A);

DUMP X;
(1L)
(2L)
(1L)
(2L)
</pre>
<a name="N130A8"></a><a name="Types+Tables-N130A8"></a>
<h4>Types Tables</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>COUNT </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
         
</tr>
   
</table>
<a name="N1310A"></a><a name="COUNT_STAR"></a>
<h3 class="h4">COUNT_STAR</h3>
<p>Computes the number of elements in a bag. </p>
<a name="N13113"></a><a name="Syntax-N13113"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>COUNT_STAR(expression)&nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N13125"></a><a name="Terms-N13125"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression with data type bag.</p>
            
</td>
         
</tr>
   
</table>
<a name="N1313D"></a><a name="Usage-N1313D"></a>
<h4>Usage</h4>
<p>Use the COUNT_STAR function to compute the number of elements in a bag.
   COUNT_STAR requires a preceding GROUP ALL statement for global counts and a GROUP BY statement for group counts.</p>
<p>COUNT_STAR includes NULL values in the count computation 
   (unlike <a href="#COUNT">COUNT</a>, which ignores NULL values).
   </p>
<a name="N1314E"></a><a name="Example-N1314E"></a>
<h4>Example</h4>
<p>In this example COUNT_STAR is used the count the tuples in a bag.</p>
<pre class="code">
X = FOREACH B GENERATE COUNT_STAR(A);
</pre>
<a name="N1315C"></a><a name="DIFF"></a>
<h3 class="h4">DIFF</h3>
<p>Compares two fields in a tuple.</p>
<a name="N13165"></a><a name="Syntax-N13165"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>DIFF (expression, expression)</p>
            
</td>
         
</tr>
   
</table>
<a name="N13177"></a><a name="Terms-N13177"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression with any data type.</p>
            
</td>
         
</tr>
   
</table>
<a name="N1318F"></a><a name="Usage-N1318F"></a>
<h4>Usage</h4>
<p>The DIFF function compares two fields in a tuple. If the field values match, null is returned. If the field values do not match, the non-matching elements are returned.</p>
<a name="N13198"></a><a name="Example-N13198"></a>
<h4>Example</h4>
<p>In this example the two fields are bags. DIFF compares the tuples in each bag.</p>
<pre class="code">
A = LOAD 'bag_data' AS (B1:bag{T1:tuple(t1:int,t2:int)},B2:bag{T2:tuple(f1:int,f2:int)});

DUMP A;
({(8,9),(0,1)},{(8,9),(1,1)})
({(2,3),(4,5)},{(2,3),(4,5)})
({(6,7),(3,7)},{(2,2),(3,7)})

DESCRIBE A;
a: {B1: {T1: (t1: int,t2: int)},B2: {T2: (f1: int,f2: int)}}

X = FOREACH A DIFF(B1,B2);

grunt&gt; dump x;
({(0,1),(1,1)})
({})
({(6,7),(2,2)})
</pre>
<a name="N131A5"></a><a name="IsEmpty"></a>
<h3 class="h4">IsEmpty</h3>
<p>Checks if a bag or map is empty.</p>
<a name="N131AE"></a><a name="Syntax-N131AE"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>IsEmpty(expression)</p>
            
</td>
         
</tr>
   
</table>
<a name="N131C0"></a><a name="Terms-N131C0"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression with any data type.</p>
            
</td>
         
</tr>
   
</table>
<a name="N131D8"></a><a name="Usage-N131D8"></a>
<h4>Usage</h4>
<p>The IsEmpty function checks if a bag or map is empty (has no data). The function can be used to filter data.</p>
<a name="N131E1"></a><a name="Example-N131E1"></a>
<h4>Example</h4>
<p>In this example all students with an SSN but no name are located.</p>
<pre class="code">
SSN = load 'ssn.txt' using PigStorage() as (ssn:long);

SSN_NAME = load 'students.txt' using PigStorage() as (ssn:long, name:chararray);

-- do a left out join of SSN with SSN_Name
X = cogroup SSN by ssn inner, SSN_NAME by ssn;

-- only keep those ssn's for which there is no name
Y = filter X by IsEmpty(SSN_NAME);
</pre>
<a name="N131EE"></a><a name="MAX"></a>
<h3 class="h4">MAX</h3>
<p>Computes the maximum of the numeric values or chararrays in a single-column bag. MAX requires a preceding GROUP ALL statement for global maximums and a GROUP BY statement for group maximums.</p>
<a name="N131F7"></a><a name="Syntax-N131F7"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>MAX(expression)&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N13209"></a><a name="Terms-N13209"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression with data types int, long, float, double, or chararray.</p>
            
</td>
         
</tr>
   
</table>
<a name="N13221"></a><a name="Usage-N13221"></a>
<h4>Usage</h4>
<p>Use the MAX function to compute the maximum of the numeric values or chararrays in a single-column bag.</p>
<a name="N1322A"></a><a name="Example-N1322A"></a>
<h4>Example</h4>
<p>In this example the maximum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</p>
<pre class="code">
A = LOAD 'student' AS (name:chararray, session:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

X = FOREACH B GENERATE group, MAX(A.gpa);

DUMP X;
(John,4.0F)
(Mary,4.0F)
</pre>
<a name="N13237"></a><a name="Types+Tables-N13237"></a>
<h4>Types Tables</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>MAX </p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>cast as double</p>
            
</td>
         
</tr>
   
</table>
<a name="N13299"></a><a name="MIN"></a>
<h3 class="h4">MIN</h3>
<p>Computes the minimum of the numeric values or chararrays in a single-column bag. MIN requires a preceding GROUP&hellip; ALL statement for global minimums and a GROUP &hellip; BY statement for group minimums.</p>
<a name="N132A2"></a><a name="Syntax-N132A2"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>MIN(expression)</p>
            
</td>
         
</tr>
   
</table>
<a name="N132B4"></a><a name="Terms-N132B4"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression with data types int, long, float, double, or chararray.</p>
            
</td>
         
</tr>
   
</table>
<a name="N132CC"></a><a name="Usage-N132CC"></a>
<h4>Usage</h4>
<p>Use the MIN function to compute the minimum of a set of numeric values or chararrays in a single-column bag.</p>
<a name="N132D5"></a><a name="Example-N132D5"></a>
<h4>Example</h4>
<p>In this example the minimum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</p>
<pre class="code">
A = LOAD 'student' AS (name:chararray, session:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

X = FOREACH B GENERATE group, MIN(A.gpa);

DUMP X;
(John,3.7F)
(Mary,3.8F)
</pre>
<a name="N132E2"></a><a name="Types+Tables-N132E2"></a>
<h4>Types Tables</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>MIN </p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>cast as double</p>
            
</td>
         
</tr>
   
</table>
<a name="N13344"></a><a name="SIZE"></a>
<h3 class="h4">SIZE</h3>
<p>Computes the number of elements based on any Pig data type. </p>
<a name="N1334D"></a><a name="Syntax-N1334D"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>SIZE(expression)</p>
            
</td>
         
</tr>
   
</table>
<a name="N1335F"></a><a name="Terms-N1335F"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression with any data type.</p>
            
</td>
         
</tr>
   
</table>
<a name="N13377"></a><a name="Usage-N13377"></a>
<h4>Usage</h4>
<p>Use the SIZE function to compute the number of elements based on the data type (see the Types Tables below). 
   SIZE includes NULL values in the size computation. SIZE is not algebraic.</p>
<a name="N13381"></a><a name="Example-N13381"></a>
<h4>Example</h4>
<p>In this example the number of characters in the first field is computed.</p>
<pre class="code">
A = LOAD 'data' as (f1:chararray, f2:chararray, f3:chararray);
(apache,open,source)
(hadoop,map,reduce)
(pig,pig,latin)

X = FOREACH A GENERATE SIZE(f1);

DUMP X;
(6L)
(6L)
(3L)
</pre>
<a name="N1338E"></a><a name="Types+Tables-N1338E"></a>
<h4>Types Tables</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>int </p>
            
</td>
            <td>
               
<p>returns 1 </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>long </p>
            
</td>
            <td>
               
<p>returns 1 </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>float </p>
            
</td>
            <td>
               
<p>returns 1 </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>double </p>
            
</td>
            <td>
               
<p>returns 1 </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>returns number of characters in the array </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bytearray </p>
            
</td>
            <td>
               
<p>returns number of bytes in the array </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>tuple </p>
            
</td>
            <td>
               
<p>returns number of fields in the tuple</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>bag </p>
            
</td>
            <td>
               
<p>returns number of tuples in bag </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>map </p>
            
</td>
            <td>
               
<p>returns number of key/value pairs in map </p>
            
</td>
         
</tr>
   
</table>
<a name="N1341E"></a><a name="SUM"></a>
<h3 class="h4">SUM</h3>
<p>Computes the sum of the numeric values in a single-column bag. SUM requires a preceding GROUP ALL statement for global sums and a GROUP BY statement for group sums.</p>
<a name="N13427"></a><a name="Syntax-N13427"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>SUM(expression)&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N13439"></a><a name="Terms-N13439"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression with data types int, long, float, double, or bytearray cast as double.</p>
            
</td>
         
</tr>
   
</table>
<a name="N13451"></a><a name="Usage-N13451"></a>
<h4>Usage</h4>
<p>Use the SUM function to compute the sum of a set of numeric values in a single-column bag.</p>
<a name="N1345A"></a><a name="Example-N1345A"></a>
<h4>Example</h4>
<p>In this example the number of pets is computed. (see the GROUP operator for information about the field names in relation B).</p>
<pre class="code">
A = LOAD 'data' AS (owner:chararray, pet_type:chararray, pet_num:int);

DUMP A;
(Alice,turtle,1)
(Alice,goldfish,5)
(Alice,cat,2)
(Bob,dog,2)
(Bob,cat,2) 

B = GROUP A BY owner;

DUMP B;
(Alice,{(Alice,turtle,1),(Alice,goldfish,5),(Alice,cat,2)})
(Bob,{(Bob,dog,2),(Bob,cat,2)})

X = FOREACH B GENERATE group, SUM(A.pet_num);
DUMP X;
(Alice,8L)
(Bob,4L)
</pre>
<a name="N13467"></a><a name="Types+Tables-N13467"></a>
<h4>Types Tables</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p></p>
            
</td>
            <td>
               
<p>int </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>float </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>chararray </p>
            
</td>
            <td>
               
<p>bytearray </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>SUM </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>long </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>double </p>
            
</td>
            <td>
               
<p>error </p>
            
</td>
            <td>
               
<p>cast as double </p>
            
</td>
         
</tr>
   
</table>
<a name="N134C9"></a><a name="TOKENIZE"></a>
<h3 class="h4">TOKENIZE</h3>
<p>Splits a string and outputs a bag of words. </p>
<a name="N134D2"></a><a name="Syntax-N134D2"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>TOKENIZE(expression)&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N134E4"></a><a name="Terms-N134E4"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>expression</p>
            
</td>
            <td>
               
<p>An expression with data type chararray.</p>
            
</td>
         
</tr>
   
</table>
<a name="N134FC"></a><a name="Usage-N134FC"></a>
<h4>Usage</h4>
<p>Use the TOKENIZE function to split a string of words (all words in a single tuple) into a bag of words (each word in a single tuple). The following characters are considered to be word separators: space, double quote("), coma(,) parenthesis(()), star(*).</p>
<a name="N13506"></a><a name="Example-N13506"></a>
<h4>Example</h4>
<p>In this example the strings in each row are split.</p>
<pre class="code">
A  = LOAD 'data' AS (f1:chararray);

DUMP A;
(Here is the first string.)
(Here is the second string.)
(Here is the third string.)

X = FOREACH A GENERATE TOKENIZE(f1);

DUMP X;
({(Here),(is),(the),(first),(string.)})
({(Here),(is),(the),(second),(string.)})
({(Here),(is),(the),(third),(string.)})
</pre>
</div>
   
   
<a name="N13513"></a><a name="Load%2FStore+Functions"></a>
<h2 class="h3">Load/Store Functions</h2>
<div class="section">
<p>Load/Store functions determine how data goes into Pig and comes out of Pig. 
   Pig provides a set of built-in load/store functions, described in the sections below. 
   You can also write your own load/store functions  (see the <a href="udf.html#Load%2FStore+Functions">Pig UDF Manual</a>).</p>
<a name="N13520"></a><a name="Handling+Compression"></a>
<h3 class="h4">Handling Compression</h3>
<p>Support for compression is determined by the load/store function. PigStorage and TextLoader support gzip and bzip compression for both read (load) and write (store). BinStorage does not support compression.</p>
<p>To work with gzip compressed files, input/output files need to have a .gz extension. Gzipped files cannot be split across multiple maps; this means that the number of maps created is equal to the number of part files in the input location.</p>
<pre class="code">
A = load &lsquo;myinput.gz&rsquo;;
store A into &lsquo;myoutput.gz&rsquo;; 
</pre>
<p>To work with bzip compressed files, the input/output files need to have a .bz or .bz2 extension. Because the compression is block-oriented, bzipped files can be split across multiple maps.</p>
<pre class="code">
A = load &lsquo;myinput.bz&rsquo;;
store A into &lsquo;myoutput.bz&rsquo;; 
</pre>
<p>Note: PigStorage and TextLoader correctly read compressed files as long as they are NOT CONCATENATED FILES generated in this manner: </p>
<ul>
      
<li>
         
<p>cat *.gz &gt; text/concat.gz</p>
      
</li>
      
<li>
         
<p>cat *.bz &gt; text/concat.bz </p>
      
</li>
      
<li>
         
<p>cat *.bz2 &gt; text/concat.bz2</p>
      
</li>
   
</ul>
<p>If you use concatenated gzip or bzip files with your Pig jobs, you will NOT see a failure but the results will be INCORRECT.</p>
<p></p>
<a name="N13553"></a><a name="BinStorage"></a>
<h3 class="h4">BinStorage</h3>
<p>Loads and stores data in machine-readable format.</p>
<a name="N1355C"></a><a name="Syntax-N1355C"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>BinStorage()&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N1356E"></a><a name="Terms-N1356E"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>none</p>
            
</td>
            <td>
               
<p>no parameters</p>
            
</td>
         
</tr>
   
</table>
<a name="N13586"></a><a name="Usage-N13586"></a>
<h4>Usage</h4>
<p>BinStorage works with data that is represented on disk in machine-readable format. 
   BinStorage does NOT support <a href="#Handling+Compression">compression</a>.</p>
<p>BinStorage is used internally by Pig to store the temporary data that is created between multiple map/reduce jobs.</p>
<a name="N13596"></a><a name="Example-N13596"></a>
<h4>Example</h4>
<p>In this example BinStorage is used with the LOAD and STORE functions.</p>
<pre class="code">
A = LOAD 'data' USING BinStorage();

STORE X into 'output' USING BinStorage(); 
</pre>
<a name="N135A3"></a><a name="PigStorage"></a>
<h3 class="h4">PigStorage</h3>
<p>Loads and stores data in UTF-8 format.</p>
<a name="N135AC"></a><a name="Syntax-N135AC"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>PigStorage(field_delimiter)&nbsp;</p>
            
</td>
         
</tr>
   
</table>
<a name="N135BE"></a><a name="Terms-N135BE"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>field_delimiter</p>
            
</td>
            <td>
               
<p>Parameter. </p>
               
<p>The default field delimiter is tab ('\t'). </p>
               
<p>You can specify other characters as field delimiters; however, be sure to encase the characters in single quotes.</p>
            
</td>
         
</tr>
   
</table>
<a name="N135DC"></a><a name="Usage-N135DC"></a>
<h4>Usage</h4>
<p>PigStorage is the default function for the LOAD and STORE operators and works with both simple and complex data types. </p>
<p>PigStorage supports structured text files (in human-readable UTF-8 format). PigStorage also supports <a href="#Handling+Compression">compression</a>.</p>
<p>Load statements &ndash; PigStorage expects data to be formatted using field delimiters, either the tab character  ('\t') or other specified character.</p>
<p>Store statements &ndash; PigStorage outputs data using field deliminters, either the tab character  ('\t') or other specified character, and the line feed record delimiter ('\n').  </p>
<p>Field Delimiters &ndash; For load and store statements the default field delimiter is the tab character ('\t'). You can use other characters as field delimiters, but separators such as ^A or Ctrl-A should be represented in Unicode (\u0001) using UTF-16 encoding (see Wikipedia <a href="http://en.wikipedia.org/wiki/ASCII">ASCII</a>, <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a>, and <a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16</a>).</p>
<p>Record Deliminters &ndash; For load statements Pig interprets the line feed ( '\n' ), carriage return ( '\r' or CTRL-M) and combined CR + LF ( '\r\n' ) characters as record delimiters (do not use these characters as field delimiters). For store statements Pig uses the line feed ('\n') character as the record delimiter.</p>
<a name="N13605"></a><a name="Example-N13605"></a>
<h4>Example</h4>
<p>In this example PigStorage expects input.txt to contain tab-separated fields and newline-separated records. The statements are equivalent.</p>
<pre class="code">
A = LOAD 'student' USING PigStorage('\t') AS (name: chararray, age:int, gpa: float); 

A = LOAD 'student' AS (name: chararray, age:int, gpa: float);
</pre>
<p>In this example PigStorage stores the contents of X into files with fields that are delimited with an asterisk ( * ). The STORE function specifies that the files will be located in a directory named output and that the files will be named part-nnnnn (for example, part-00000).</p>
<pre class="code">
STORE X INTO  'output' USING PigStorage('*');
</pre>
<a name="N13618"></a><a name="PigDump"></a>
<h3 class="h4">PigDump</h3>
<p>Stores data in UTF-8 format.</p>
<a name="N13621"></a><a name="Syntax-N13621"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>PigDump()&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N13633"></a><a name="Terms-N13633"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>none</p>
            
</td>
            <td>
               
<p>no parameters</p>
            
</td>
         
</tr>
   
</table>
<a name="N1364B"></a><a name="Usage-N1364B"></a>
<h4>Usage</h4>
<p>PigDump stores data as tuples in human-readable UTF-8 format. </p>
<a name="N13654"></a><a name="Example-N13654"></a>
<h4>Example</h4>
<p>In this example PigDump is used with the STORE function.</p>
<pre class="code">
STORE X INTO 'output' USING PigDump();
</pre>
<a name="N13661"></a><a name="TextLoader"></a>
<h3 class="h4">TextLoader</h3>
<p>Loads unstructured data in UTF-8 format.</p>
<a name="N1366A"></a><a name="Syntax-N1366A"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>TextLoader()</p>
            
</td>
         
</tr>
   
</table>
<a name="N1367D"></a><a name="Terms-N1367D"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>none</p>
            
</td>
            <td>
               
<p>no parameters</p>
            
</td>
         
</tr>
   
</table>
<a name="N13695"></a><a name="Usage-N13695"></a>
<h4>Usage</h4>
<p>TextLoader works with unstructured data in UTF8 format. Each resulting tuple contains a single field with one line of input text. TextLoader also supports <a href="#Handling+Compression">compression</a>.</p>
<p>Currently, TextLoader support for compression is limited.</p>
<p>TextLoader cannot be used to store data.</p>
<a name="N136A9"></a><a name="Example-N136A9"></a>
<h4>Example</h4>
<p>In this example TextLoader is used with the LOAD function.</p>
<pre class="code">
A = LOAD 'data' USING TextLoader();
</pre>
</div>
   
      <!-- Shell COMMANDS-->
   
<a name="N136B8"></a><a name="Shell+Commands"></a>
<h2 class="h3">Shell Commands</h2>
<div class="section">
<a name="N136BE"></a><a name="fs"></a>
<h3 class="h4">fs</h3>
<p>Invokes any FSShell command from within a Pig script or the Grunt shell.</p>
<a name="N136C7"></a><a name="Syntax-N136C7"></a>
<h4>Syntax </h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>fs subcommand subcommand_parameters </p>
            
</td>
         
</tr>
   
</table>
<a name="N136D9"></a><a name="Terms-N136D9"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
      
<tr>
            
<td>
               
<p>subcommand</p>
            
</td>
            <td>
               
<p>The FSShell command.</p>
            
</td>
         
</tr>
               
<tr>
            
<td>
               
<p>subcommand_parameters</p>
            
</td>
            <td>
               
<p>The FSShell command parameters.</p>
            
</td>
         
</tr>
         
   
</table>
<a name="N13701"></a><a name="Usage-N13701"></a>
<h4>Usage</h4>
<p>Use the fs command to invoke any FSShell command from within a Pig script or Grunt shell. 
   The fs command greatly extends the set of supported file system commands and the capabilities
   supported for existing commands such as ls that will now support globing. For a complete list of
   FSShell commands, see 
   <a href="http://hadoop.apache.org/common/docs/current/hdfs_shell.html">HDFS File System Shell Guide</a>
</p>
<a name="N1370E"></a><a name="Examples-N1370E"></a>
<h4>Examples</h4>
<p>In these examples, a directory is created, a file is copied, a file is listed.</p>
<pre class="code">
fs -mkdir /tmp
fs -copyFromLocal file-x file-y
fs -ls file-y
</pre>
</div>
    
   <!-- FILE COMMANDS-->
   
<a name="N1371F"></a><a name="File+Commands"></a>
<h2 class="h3">File Commands</h2>
<div class="section">
<p>Note: Beginning with Pig 0.6.0, the file commands are now deprecated and will be removed in a future release. 
   Start using Pig's -fs command to invoke the shell commands <a href="#Shell+Commands">shell commands</a>.   
   </p>
<a name="N1372C"></a><a name="cat"></a>
<h3 class="h4">cat</h3>
<p>Prints the content of one or more files to the screen.</p>
<a name="N13735"></a><a name="Syntax-N13735"></a>
<h4>Syntax </h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>cat path [ path &hellip;]</p>
            
</td>
         
</tr>
   
</table>
<a name="N13747"></a><a name="Terms-N13747"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>path</p>
            
</td>
            <td>
               
<p>The location of a file or directory.</p>
            
</td>
         
</tr>
   
</table>
<a name="N1375F"></a><a name="Usage-N1375F"></a>
<h4>Usage</h4>
<p>The cat command is similar to the Unix cat command. If multiple files are specified, content from all files is concatenated together. If multiple directories are specified, content from all files in all directories is concatenated together.</p>
<a name="N13769"></a><a name="Example-N13769"></a>
<h4>Example</h4>
<p>In this example the students file in the data directory is printed.</p>
<pre class="code">
grunt&gt; cat data/students;
joe smith
john adams
anne white
</pre>
<a name="N13777"></a><a name="cd"></a>
<h3 class="h4">cd</h3>
<p>Changes the current directory to another directory.</p>
<a name="N13780"></a><a name="Syntax-N13780"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>cd [dir]</p>
            
</td>
         
</tr>
   
</table>
<a name="N13792"></a><a name="Terms-N13792"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>dir</p>
            
</td>
            <td>
               
<p>The name of the directory you want to navigate to.</p>
            
</td>
         
</tr>
   
</table>
<a name="N137AA"></a><a name="Usage-N137AA"></a>
<h4>Usage</h4>
<p>The cd command is similar to the Unix cd command and can be used to navigate the file system. If a directory is specified, this directory is made your current working directory and all other operations happen relatively to this directory. If no directory is specified, your home directory (/user/NAME) becomes the current working directory. </p>
<a name="N137B4"></a><a name="Example-N137B4"></a>
<h4>Example</h4>
<p>In this example we move to the /data directory.</p>
<pre class="code">
grunt&gt; cd /data
</pre>
<a name="N137C1"></a><a name="copyFromLocal"></a>
<h3 class="h4">copyFromLocal</h3>
<p>Copies a file or directory from the local file system to HDFS.</p>
<a name="N137CA"></a><a name="Syntax-N137CA"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>copyFromLocal src_path dst_path</p>
            
</td>
         
</tr>
   
</table>
<a name="N137DC"></a><a name="Terms-N137DC"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>src_path</p>
            
</td>
            <td>
               
<p>The path on the local file system for a file or directory</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>dst_path</p>
            
</td>
            <td>
               
<p>The path on HDFS.</p>
            
</td>
         
</tr>
   
</table>
<a name="N13803"></a><a name="Usage-N13803"></a>
<h4>Usage</h4>
<p>The copyFromLocal command enables you to copy a file or a director from the local file system to the Hadoop Distributed File System (HDFS). If a directory is specified, it is recursively copied over. Dot "." can be used to specify that the new file/directory should be created in the current working directory and retain the name of the source file/directory. </p>
<a name="N1380D"></a><a name="Example-N1380D"></a>
<h4>Example</h4>
<p>In this example a file (students) and a directory (/data/tests) are copied from the local file system to HDFS.</p>
<pre class="code">
grunt&gt; copyFromLocal /data/students students

grunt&gt; ls students
/data/students &lt;r 3&gt; 8270

grunt&gt;  copyFromLocal  /data/tests new_tests

grunt&gt; ls new_test
/data/new_test/test1.data &lt;r 3&gt; 664
/data/new_test/test2.data &lt;r 3&gt; 344
/data/new_test/more_data   
</pre>
<a name="N1381A"></a><a name="copyToLocal"></a>
<h3 class="h4">copyToLocal</h3>
<p>Copies a file or directory from HDFS to a local file system. </p>
<a name="N13823"></a><a name="Syntax-N13823"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>copyToLocal src_path dst_path</p>
            
</td>
         
</tr>
   
</table>
<a name="N13835"></a><a name="Terms-N13835"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>src_path</p>
            
</td>
            <td>
               
<p>The path on HDFS.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>dst_path</p>
            
</td>
            <td>
               
<p>The path on the local file system for a file or directory.</p>
            
</td>
         
</tr>
   
</table>
<a name="N1385C"></a><a name="Usage-N1385C"></a>
<h4>Usage</h4>
<p>The copyToLocal command enables you to copy a file or a director from Hadoop Distributed File System (HDFS) to a local file system. If a directory is specified, it is recursively copied over. Dot "." can be used to specify that the new file/directory should be created in the current working directory (directory from which the script was executed or grunt shell started) and retain the name of the source file/directory. </p>
<a name="N13866"></a><a name="Example-N13866"></a>
<h4>Example</h4>
<p>In this example two files are copied from HDFS to the local file system.</p>
<pre class="code">
grunt&gt; copyToLocal students /data
grunt&gt; copyToLocal data /data/mydata
</pre>
<a name="N13873"></a><a name="cp"></a>
<h3 class="h4">cp</h3>
<p>Copies a file or directory within HDFS.</p>
<a name="N1387C"></a><a name="Syntax-N1387C"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>cp src_path dst_path&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N1388E"></a><a name="Terms-N1388E"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>src_path</p>
            
</td>
            <td>
               
<p>The path on HDFS.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>dst_path</p>
            
</td>
            <td>
               
<p>The path on HDFS.</p>
            
</td>
         
</tr>
   
</table>
<a name="N138B5"></a><a name="Usage-N138B5"></a>
<h4>Usage</h4>
<p>The cp command is similar to the Unix cp command and enables you to copy files or directories within DFS. If a directory is specified, it is recursively copied over. Dot "." can be used to specify that the new file/directory should be created in the current working directory and retain the name of the source file/directory. </p>
<a name="N138BF"></a><a name="Example-N138BF"></a>
<h4>Example</h4>
<p>In this example a file (students) is copied to another file (students_save).</p>
<pre class="code">
grunt&gt; cp students students_save
</pre>
<a name="N138CC"></a><a name="ls"></a>
<h3 class="h4">ls</h3>
<p>Lists the contents of a directory.</p>
<a name="N138D5"></a><a name="Syntax-N138D5"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>ls [path]&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N138E7"></a><a name="Terms-N138E7"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>path</p>
            
</td>
            <td>
               
<p>The name of the path/directory.</p>
            
</td>
         
</tr>
   
</table>
<a name="N138FF"></a><a name="Usage-N138FF"></a>
<h4>Usage</h4>
<p>The ls command is similar to the Unix ls command and enables you to list the contents of a directory. If DIR is specified, the command lists the content of the specified directory. Otherwise, the content of the current working directory is listed. </p>
<a name="N13909"></a><a name="Example-N13909"></a>
<h4>Example</h4>
<p>In this example the contents of the data directory are listed.</p>
<pre class="code">
grunt&gt; ls /data
/data/DDLs &nbsp;&lt;dir&gt;
/data/count &lt;dir&gt;
/data/data &nbsp;&lt;dir&gt;
/data/schema &lt;dir&gt;
</pre>
<a name="N13916"></a><a name="mkdir"></a>
<h3 class="h4">mkdir</h3>
<p>Creates a new directory.</p>
<a name="N1391F"></a><a name="Syntax-N1391F"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>mkdir path&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N13931"></a><a name="Terms-N13931"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>path</p>
            
</td>
            <td>
               
<p>The name of the path/directory.</p>
            
</td>
         
</tr>
   
</table>
<a name="N13949"></a><a name="Usage-N13949"></a>
<h4>Usage</h4>
<p>The mkdir command is similar to the Unix mkdir command and enables you to create a new directory. If you specify a directory or path that does not exist, it will be created.</p>
<a name="N13953"></a><a name="Example-N13953"></a>
<h4>Example</h4>
<p>In this example a directory and subdirectory are created.</p>
<pre class="code">
grunt&gt; mkdir data/20070905
</pre>
<a name="N13960"></a><a name="mv"></a>
<h3 class="h4">mv</h3>
<p>Moves a file or directory within the Hadoop Distributed File System (HDFS).</p>
<a name="N13969"></a><a name="Syntax-N13969"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>mv src_path dst_path</p>
            
</td>
         
</tr>
   
</table>
<a name="N1397B"></a><a name="Terms-N1397B"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>src_path</p>
            
</td>
            <td>
               
<p>The path on HDFS.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>dst_path</p>
            
</td>
            <td>
               
<p>The path on HDFS.</p>
            
</td>
         
</tr>
   
</table>
<a name="N139A2"></a><a name="Usage-N139A2"></a>
<h4>Usage</h4>
<p>The mv command is identical to the Unix mv command (which copies files or directories within DFS) except that it deletes the source file or directory as soon as it is copied.</p>
<p>If a directory is specified, it is recursively moved. Dot "." can be used to specify that the new file/directory should be created in the current working directory and retain the name of the source file/directory. &nbsp;</p>
<a name="N139AF"></a><a name="Example-N139AF"></a>
<h4>Example</h4>
<p>In this example the output directory is copied to output2 and then deleted.</p>
<pre class="code">
grunt&gt; mv output output2

grunt&gt; ls output
File or directory output does not exist.

grunt&gt; ls output2
/data/output2/map-000000&lt;r 3&gt; &nbsp; &nbsp; 508844
/data/output2/output3 &nbsp; &nbsp; &lt;dir&gt;
/data/output2/part-00000&lt;r 3&gt; &nbsp; &nbsp; 0
</pre>
<a name="N139BC"></a><a name="pwd"></a>
<h3 class="h4">pwd</h3>
<p></p>
<p>Prints the name of the current working directory. </p>
<a name="N139C7"></a><a name="Syntax-N139C7"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>pwd</p>
            
</td>
         
</tr>
   
</table>
<a name="N139D9"></a><a name="Terms-N139D9"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>none</p>
            
</td>
            <td>
               
<p>no parameters</p>
            
</td>
         
</tr>
   
</table>
<a name="N139F1"></a><a name="Usage-N139F1"></a>
<h4>Usage</h4>
<p>The pwd command is identical to Unix pwd command and it prints the name of the current working directory. </p>
<a name="N139FA"></a><a name="Example-N139FA"></a>
<h4>Example</h4>
<p>In this example the name of the current working directory is /data.</p>
<pre class="code">
grunt&gt; pwd
/data
</pre>
<a name="N13A07"></a><a name="rm"></a>
<h3 class="h4">rm</h3>
<p>Removes one or more files or directories. </p>
<a name="N13A10"></a><a name="Syntax-N13A10"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>rm path [path&hellip;]&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N13A22"></a><a name="Terms-N13A22"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>path</p>
            
</td>
            <td>
               
<p>The name of the path/directory/file.</p>
            
</td>
         
</tr>
   
</table>
<a name="N13A3A"></a><a name="Usage-N13A3A"></a>
<h4>Usage</h4>
<p>The rm command is similar to the Unix rm command and enables you to remove one or more files or directories.</p>
<p>Note: This command recursively removes a directory even if it is not empty and it does not confirm remove and the removed data is not recoverable. </p>
<a name="N13A46"></a><a name="Example-N13A46"></a>
<h4>Example</h4>
<p>In this example files are removed.</p>
<pre class="code">
grunt&gt; rm /data/students
grunt&gt; rm students students_sav
</pre>
<a name="N13A53"></a><a name="rmf"></a>
<h3 class="h4">rmf</h3>
<p>Forcibly removes one or more files or directories. </p>
<a name="N13A5C"></a><a name="Syntax-N13A5C"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>rmf path [path &hellip;]&nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N13A6E"></a><a name="Terms-N13A6E"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>path</p>
            
</td>
            <td>
               
<p>The name of the path/directory/file.</p>
            
</td>
         
</tr>
   
</table>
<a name="N13A86"></a><a name="Usage-N13A86"></a>
<h4>Usage</h4>
<p>The rmf command is similar to the Unix rm -f command and enables you to forcibly remove one or more files or directories.</p>
<p>Note: This command recursively removes a directory even if it is not empty and it does not confirm remove and the removed data is not recoverable. </p>
<a name="N13A93"></a><a name="Example-N13A93"></a>
<h4>Example</h4>
<p>In this example files are forcibly removed.</p>
<pre class="code">
grunt&gt; rmf /data/students
grunt&gt; rmf students students_sav
</pre>
</div>
   
   
   
<a name="N13AA1"></a><a name="Utility+Commands"></a>
<h2 class="h3">Utility Commands</h2>
<div class="section">
<a name="N13AA7"></a><a name="exec"></a>
<h3 class="h4">exec</h3>
<p>Run a Pig script.</p>
<a name="N13AB0"></a><a name="Syntax-N13AB0"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>exec [&ndash;param param_name = param_value] [&ndash;param_file file_name] script&nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N13AC2"></a><a name="Terms-N13AC2"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
   
        
<tr>
            
<td>
               
<p>&ndash;param param_name = param_value</p>
            
</td>
            <td>
               
<p>See Parameter Substitution.</p>
            
</td>
        
</tr>

        
<tr>
            
<td>
               
<p>&ndash;param_file file_name</p>
            
</td>
            <td>
               
<p>See Parameter Substitution. </p>
            
</td>
        
</tr>
   
      
<tr>
            
<td>
               
<p>script</p>
            
</td>
            <td>
               
<p>The name of a Pig script.</p>
            
</td>
         
</tr>
         
   
   
</table>
<a name="N13AF8"></a><a name="Usage-N13AF8"></a>
<h4>Usage</h4>
<p>Use the exec command to run a Pig script with no interaction between the script and the Grunt shell (batch mode). Aliases defined in the script are not available to the shell; however, the files produced as the output of the script and stored on the system are visible after the script is run. Aliases defined via the shell are not available to the script. </p>
<p>With the exec command, store statements will not trigger execution; rather, the entire script is parsed before execution starts. Unlike the run command, exec does not change the command history or remembers the handles used inside the script. Exec without any parameters can be used in scripts to force execution up to the point in the script where the exec occurs. </p>
<p>For comparison, see the run command. Both the exec and run commands are useful for debugging because you can modify a Pig script in an editor and then rerun the script in the Grunt shell without leaving the shell. Also, both commands promote Pig script modularity as they allow you to reuse existing components.</p>
<a name="N13B08"></a><a name="Examples-N13B08"></a>
<h4>Examples</h4>
<p>In this example the script is displayed and run.</p>
<pre class="code">
grunt&gt; cat myscript.pig
a = LOAD 'student' AS (name, age, gpa);
b = LIMIT a 3;
DUMP b;

grunt&gt; exec myscript.pig
(alice,20,2.47)
(luke,18,4.00)
(holly,24,3.27)
</pre>
<p>In this example parameter substitution is used with the exec command.</p>
<pre class="code">
grunt&gt; cat myscript.pig
a = LOAD 'student' AS (name, age, gpa);
b = ORDER a BY name;

STORE b into '$out';

grunt&gt; exec &ndash;param out=myoutput myscript.pig
</pre>
<p>In this example multiple parameters are specified.</p>
<pre class="code">
grunt&gt; exec &ndash;param p1=myparam1 &ndash;param p2=myparam2 myscript.pig
</pre>
<a name="N13B22"></a><a name="help"></a>
<h3 class="h4">help</h3>
<p>Prints a list of Pig commands.</p>
<a name="N13B2B"></a><a name="Syntax-N13B2B"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>help &nbsp; &nbsp; &nbsp; &nbsp; </p>
            
</td>
         
</tr>
   
</table>
<a name="N13B3D"></a><a name="Terms-N13B3D"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>none</p>
            
</td>
            <td>
               
<p>no parameters</p>
            
</td>
         
</tr>
   
</table>
<a name="N13B55"></a><a name="Usage-N13B55"></a>
<h4>Usage</h4>
<p>The help command prints a list of Pig commands.</p>
<a name="N13B5E"></a><a name="Example-N13B5E"></a>
<h4>Example</h4>
<p>In this example the students file in the data directory is printed out.</p>
<pre class="code">
grunt&gt; help
Commands:
&lt;pig latin statement&gt;;
store &lt;alias&gt; into &lt;filename&gt; [using &lt;functionSpec&gt;]
dump &lt;alias&gt;
<em>etc &hellip;</em>
</pre>
<a name="N13B6D"></a><a name="kill"></a>
<h3 class="h4">kill</h3>
<p>Kills a job.</p>
<a name="N13B76"></a><a name="Syntax-N13B76"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>kill jobid</p>
            
</td>
         
</tr>
   
</table>
<a name="N13B88"></a><a name="Terms-N13B88"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>jobid</p>
            
</td>
            <td>
               
<p>The job id.</p>
            
</td>
         
</tr>
   
</table>
<a name="N13BA0"></a><a name="Usage-N13BA0"></a>
<h4>Usage</h4>
<p>The kill command enables you to kill a job based on a job id.</p>
<a name="N13BA9"></a><a name="Example-N13BA9"></a>
<h4>Example</h4>
<p>In this example the job with id job_0001 is killed.</p>
<pre class="code">
grunt&gt; kill job_0001
</pre>
<a name="N13BB6"></a><a name="quit"></a>
<h3 class="h4">quit</h3>
<p>Quits from the Pig grunt shell.</p>
<a name="N13BBF"></a><a name="Syntax-N13BBF"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>exit</p>
            
</td>
         
</tr>
   
</table>
<a name="N13BD1"></a><a name="Terms-N13BD1"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>none</p>
            
</td>
            <td>
               
<p>no parameters</p>
            
</td>
         
</tr>
   
</table>
<a name="N13BE9"></a><a name="Usage-N13BE9"></a>
<h4>Usage</h4>
<p>The quit command enables you to quit or exit the Pig grunt shell.</p>
<a name="N13BF2"></a><a name="Example-N13BF2"></a>
<h4>Example</h4>
<p>In this example the quit command exits the Pig grunt shall.</p>
<pre class="code">
grunt&gt; quit
</pre>
<a name="N13BFF"></a><a name="run"></a>
<h3 class="h4">run</h3>
<p>Run a Pig script.</p>
<a name="N13C08"></a><a name="Syntax-N13C08"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>run [&ndash;param param_name = param_value] [&ndash;param_file file_name] script&nbsp;</p>
            
</td>
         
</tr>
   
</table>
<a name="N13C1A"></a><a name="Terms-N13C1A"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
   
         
<tr>
            
<td>
               
<p>&ndash;param param_name = param_value</p>
            
</td>
            <td>
               
<p>See Parameter Substitution.</p>
            
</td>
         
</tr>

         
<tr>
            
<td>
               
<p>&ndash;param_file file_name</p>
            
</td>
            <td>
               
<p>See Parameter Substitution. </p>
            
</td>
         
</tr>
      
<tr>
            
<td>
               
<p>script</p>
            
</td>
            <td>
               
<p>The name of a Pig script.</p>
            
</td>
         
</tr>
         
   
   
</table>
<a name="N13C50"></a><a name="Usage-N13C50"></a>
<h4>Usage</h4>
<p>Use the run command to run a Pig script that can interact with the Grunt shell (interactive mode). The script has access to aliases defined externally via the Grunt shell. The Grunt shell has access to aliases defined within the script. All commands from the script are visible in the command history. </p>
<p>With the run command, every store triggers execution. The statements from the script are put into the command history and all the aliases defined in the script can be referenced in subsequent statements after the run command has completed. Issuing a run command on the grunt command line has basically the same effect as typing the statements manually. </p>
<p>For comparison, see the exec command. Both the run and exec commands are useful for debugging because you can modify a Pig script in an editor and then rerun the script in the Grunt shell without leaving the shell. Also, both commands promote Pig script modularity as they allow you to reuse existing components.</p>
<a name="N13C60"></a><a name="Example-N13C60"></a>
<h4>Example</h4>
<p>In this example the script interacts with the results of commands issued via the Grunt shell.</p>
<pre class="code">
grunt&gt; cat myscript.pig
b = ORDER a BY name;
c = LIMIT b 10;

grunt&gt; a = LOAD 'student' AS (name, age, gpa);

grunt&gt; run myscript.pig

grunt&gt; d = LIMIT c 3;

grunt&gt; DUMP d;
(alice,20,2.47)
(alice,27,1.95)
(alice,36,2.27)
</pre>
<p>In this example parameter substitution is used with the run command.</p>
<pre class="code">
grunt&gt; a = LOAD 'student' AS (name, age, gpa);

grunt&gt; cat myscript.pig
b = ORDER a BY name;
STORE b into '$out';

grunt&gt; run &ndash;param out=myoutput myscript.pig
</pre>
<a name="N13C73"></a><a name="set"></a>
<h3 class="h4">set</h3>
<p>Assigns values to keys used in Pig.</p>
<a name="N13C7C"></a><a name="Syntax-N13C7C"></a>
<h4>Syntax</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>set key 'value'</p>
            
</td>
         
</tr>
   
</table>
<a name="N13C8E"></a><a name="Terms-N13C8E"></a>
<h4>Terms</h4>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>key</p>
            
</td>
            <td>
               
<p>Key (see table). Case sensitive.</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>value</p>
            
</td>
            <td>
               
<p>Value for key (see table). Case sensitive.</p>
            
</td>
         
</tr>
   
</table>
<a name="N13CB5"></a><a name="Usage-N13CB5"></a>
<h4>Usage</h4>
<p>The set command enables you to assign values to keys, as shown in the table. </p>
<table class="ForrestTable" cellspacing="1" cellpadding="4">
      
<tr>
            
<td>
               
<p>Key </p>
            
</td>
            <td>
               
<p>Value </p>
            
</td>
            <td>
               
<p>Description </p>
            
</td>
         
</tr>
                     
<tr>
            
<td>
               
<p>default_parallel</p>
            
</td>
            <td>
               
<p>a whole number </p>
            
</td>
            <td>
               
<p>Sets the number of reducers for all MapReduce jobs generated by Pig 
              (see  <a href="cookbook.html#Use+the+PARALLEL+Clause">Use the PARALLEL Clause</a>).</p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>debug </p>
            
</td>
            <td>
               
<p>on/off </p>
            
</td>
            <td>
               
<p>Turns debug-level logging on or off. </p>
            
</td>
         
</tr>
         
<tr>
            
<td>
               
<p>job.name </p>
            
</td>
            <td>
               
<p>Single-quoted string that contains the job name.</p>
            
</td>
            <td>
               
<p>Sets user-specified name for the job </p>
            
</td>
            
</tr>

         
<tr>
            
<td>
               
<p>job.priority </p>
            
</td>
            <td>
               
<p>Acceptable values (case insensitive): very_low, low, normal, high, very_high </p>
            
</td>
            <td>
               
<p>Sets the priority of a Pig job.</p>
            
</td>
            
</tr>

         
<tr>
            
<td>
               
<p>stream.skippath</p>
            
</td>
            <td>
               
<p>String that contains the path.</p>
            
</td>
            <td>
               
<p>For streaming, sets the path from which not to ship data (see <a href="#DEFINE">DEFINE</a> and <a href="#autoship"> About Auto-Ship</a>).</p>
            
</td>
            
</tr>

         
   
</table>
<p></p>
<a name="N13D4E"></a><a name="Example-N13D4E"></a>
<h4>Example</h4>
<p>In this example debug is set on, the job is assigned a name, and the number of reducers is set to 100.</p>
<pre class="code">
grunt&gt; set debug 'on'
grunt&gt; set job.name 'my job'
grunt&gt; set default_parallel 100
</pre>
<p>In this example default_parallel is set in the Pig script; all MapReduce jobs that get launched will use 20 reducers.</p>
<pre class="code">
SET DEFAULT_PARALLEL 20;
A = LOAD 'myfile.txt' USING PigStorage() AS (t, u, v);
B = GROUP A BY t;
C = FOREACH B GENERATE group, COUNT(A.t) as mycount;
D = ORDER C BY mycount;
STORE D INTO 'mysortedcount' USING PigStorage();
</pre>
</div>
  
   
<p align="right">
<font size="-2"></font>
</p>
</div>
<!--+
    |end content
    +-->
<div class="clearboth">&nbsp;</div>
</div>
<div id="footer">
<!--+
    |start bottomstrip
    +-->
<div class="lastmodified">
<script type="text/javascript"><!--
document.write("Last Published: " + document.lastModified);
//  --></script>
</div>
<div class="copyright">
        Copyright &copy;
         2007-2010 <a href="http://www.apache.org/licenses/">The Apache Software Foundation.</a>
</div>
<!--+
    |end bottomstrip
    +-->
</div>
</body>
</html>
